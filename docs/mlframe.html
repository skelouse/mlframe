<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>mlframe.mlframe API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mlframe.mlframe</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import inspect
from matplotlib.pyplot import title
import pandas as pd
import numpy as np
from functools import wraps, partial
import statsmodels.api as sm
import statsmodels.formula.api as smf
import scipy.stats as stats
import statsmodels.stats.api as sms
from statsmodels.stats.outliers_influence import variance_inflation_factor
from functools import wraps
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score
# import warnings
# warnings.filterwarnings(&#39;ignore&#39;)

import matplotlib.pyplot as plt
import seaborn as sns
import missingno as ms


from inspect import getmembers, isfunction
&#34;https://stackoverflow.com/questions/17393176/python-3-method-docstring-inheritance-without-breaking-decorators-or-violating&#34;
def inherit_docstrings(cls):
    for name, func in getmembers(cls, isfunction):
        if func.__doc__: continue
        for parent in cls.__mro__[1:]:
            if hasattr(parent, name):
                func.__doc__ = getattr(parent, name).__doc__
    return cls


class MLFrame(pd.DataFrame):
    &#34;&#34;&#34;A pd.DataFrame with an inplace model, and LinearRegression
    modeling functions.
    
    **See pandas.DataFrame documentation&#34;&#34;&#34;
    model = None

    def __init__(self, frame, **kwargs):
        super(MLFrame, self).__init__(frame, **kwargs)

    def cat_cols(self):
        &#34;&#34;&#34;Computes and returns Categorical columns&#34;&#34;&#34;
        return list(self.select_dtypes(&#39;object&#39;).columns)

    def num_cols(self):
        &#34;&#34;&#34;Computes and returns Numerical columns&#34;&#34;&#34;
        return list(self.select_dtypes(&#39;number&#39;).columns)

    @staticmethod
    def replace_all(string):
        &#34;&#34;&#34;Replaces bad characters in a string for
        column names to work in a R~formula&#34;&#34;&#34;
        return string.replace(
                      &#39; &#39;, &#39;_&#39;).replace(
                      &#39;(&#39;, &#39;&#39;).replace(
                      &#39;)&#39;, &#39;&#39;).replace(
                    #   &#39;1&#39;, &#39;one&#39;).replace(
                    #   &#39;2&#39;, &#39;two&#39;).replace(
                    #   &#39;3&#39;, &#39;three&#39;).replace(
                    #   &#39;4&#39;, &#39;four&#39;).replace(
                    #   &#39;5&#39;, &#39;five&#39;).replace(
                    #   &#39;6&#39;, &#39;six&#39;).replace(
                    #   &#39;7&#39;, &#39;seven&#39;).replace(
                    #   &#39;8&#39;, &#39;eight&#39;).replace(
                    #   &#39;9&#39;, &#39;nine&#39;).replace(
                      &#39;.&#39;, &#39;_&#39;).replace(
                      &#39;-&#39;, &#39;_&#39;).replace(
                      &#39;/&#39;, &#39;_&#39;).replace(
                      &#39;@&#39;, &#39;_&#39;).replace(
                      &#39;+&#39;, &#39;_&#39;).replace(
                      &#39; &#39;, &#39;_&#39;).replace(
                      &#39; &#39;, &#39;_&#39;)

    def clean_col_names(self,
                        inplace=False,
                        verbose=True):
        &#34;&#34;&#34;Cleans the column names of a DataFrame
        for use in an R~Formula

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to show the difference between
            the old columns and clean columns or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns a copy of the dataframe

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names()
        Columns changed:
        model year --&gt; model_year
        car name --&gt; car_name
        &#34;&#34;&#34;
        def show_difference(old_cols, new_cols):
            diff = dict(zip(old_cols, new_cols))
            print(&#39;\nColumns changed:&#39;)
            for col in diff.items():
                if col[0] != col[1]:
                    print(col[0], &#34;--&gt;&#34;, col[1])

        if inplace:
            new_columns = [self.replace_all(c.strip())
                            for c in self.columns.values.tolist()]
            old_columns = self.columns
            if verbose:
                show_difference(old_columns, new_columns)
            self.columns = new_columns
        else:
            df = self.copy()
            new_columns = [self.replace_all(c.strip())
                            for c in df.columns.values.tolist()]
            old_columns = df.columns
            if verbose:
                show_difference(old_columns, new_columns)
            df.columns = new_columns
            return df

    def get_vif(self, target, verbose=True):
        &#34;&#34;&#34;Computes the Variance Inflation Factor
        for the columns of a dataframe based
        on the target column

        Parameters
        ----------------------------------------
        target[str]::
            The column name to base the VIF on
        verbose[bool]::
            Whether or not to print out the VIF series

        Returns
        ----------------------------------------
        Series of variance_inflation_factor for each column

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; df.get_vif(&#39;mpg&#39;, verbose=False)
        const          763.558
        cylinders       10.738
        displacement    21.837
        horsepower       9.944
        weight          10.831
        acceleration     2.626
        model year       1.245
        origin           1.772
        &#34;&#34;&#34;
        X = self.drop(target, axis=1)
        X = sm.add_constant(X)
        vif = [variance_inflation_factor(X.values, i)
            for i in range(X.shape[1])]
        s = pd.Series(dict(zip(X.columns, vif)))
        if verbose:
            print(s)
        return s

    def get_vif_cols(self, target, threshold=6, verbose=True,
                     inplace=False):
        &#34;&#34;&#34; Computes Variance Inflation Factor
        for the dataframe, and gets the columns
        that are above the defined threshold

        Parameters
        ----------------------------------------
        target[str]::
            The column name to base the VIF on
        threshold=6[int]::
            The threshold that columns would be above
            where they are an issue, and need to be
            looked at
        verbose[bool]::
            Whether to print out the series or not
        inplace[bool]::
            Whether to return the series or not

        Returns
        ----------------------------------------
        Depending on inplace
        Series of variance_inflation_factor for each column

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; df.get_vif_cols(&#39;mpg&#39;, verbose=False)
        horsepower      9.944
        cylinders      10.738
        weight         10.831
        displacement   21.837
        dtype: float64
        &#34;&#34;&#34;
        vif_results = self.get_vif(target, verbose=False)
        bad_vif = list(vif_results[vif_results&gt;threshold].index)
        if &#39;const&#39; in bad_vif:
            bad_vif.remove(&#39;const&#39;)
        num_vif = {}
        for col in bad_vif:
            num_vif[col] = vif_results[col]
        s = pd.Series(num_vif).sort_values()
        if verbose:
            print(&#39;\nVIF columns &gt; %s: \n%s&#39;
                  % (threshold, s))
        if not inplace:
            return s

    def log(self, columns, inplace=False, verbose=True):
        &#34;&#34;&#34; logs the listed columns of the dataframe
        Parameters
        ----------------------------------------
        columns[list, str]::
            A list of columns to make logarithmic
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out logged columns or not

        Returns
        ----------------------------------------
        None if inplace otherwise returns a copy
        of the dataframe with columns logged

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
        
        &gt;&gt;&gt; df = df.log(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
        Logging:
           mpg
           cylinders
        # OR
        &gt;&gt;&gt; df.log(&#39;mpg&#39;, inplace=True)
        Logging:
           mpg
        &#34;&#34;&#34;
        if verbose:
            print(&#34;\nLogging:&#34;)
            if isinstance(columns, list):
                for col in columns:
                    print(&#34;  &#34;, col)
            else:
                print(&#34;  &#34;, columns)
        if inplace:
            if isinstance(columns, list):
                for col in columns:
                    self[col] = np.log(self[col])
            else:
                self[columns] = np.log(self[columns])
        else:
            df = self.copy()
            if isinstance(columns, list):
                for col in columns:
                    df[col] = np.log(df[col])
            else:
                df[columns] = np.log(df[columns])
            return df

    def scale(self, columns, inplace=False, verbose=True):
        &#34;&#34;&#34; Scales the listed columns of the dataframe
        Parameters
        ----------------------------------------
        columns[list, str]::
            A list of columns to scale
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out the scaled columns or not

        Returns:
            None if inplace otherwise returns a copy
            of the dataframe with columns scaled

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
        
        &gt;&gt;&gt; df = df.scale(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
        Scaling:
           mpg
           cylinders
        # OR
        &gt;&gt;&gt; df.scale(&#39;mpg&#39;, inplace=True)
        Scaling:
           mpg
        &#34;&#34;&#34;
        def scale(df, col):
            df[col] = ((df[col] - np.mean(df[col]))
                      / np.sqrt(np.var(df[col])))
        if verbose:
            print(&#34;\nScaling:&#34;)
            if isinstance(columns, list):
                for col in columns:
                    print(&#34;  &#34;, col)
            else:
                print(&#34;  &#34;, columns)
        if inplace:
            if isinstance(columns, list):
                for col in columns:
                    scale(self, col)
            else:
                scale(self, columns)
        else:
            df = self.copy()
            if isinstance(columns, list):
                for col in columns:
                    scale(df, col)
            else:
                scale(df, columns)
            return df

    def wrapper(func):
        &#34;&#34;&#34;Wrapper to return a MLFrame, and set
        the model when defined pd.DataFrame methods
        are used on a MLFrame&#34;&#34;&#34;
        @wraps(func)
        @inherit_docstrings
        def inner(self, *args, **kwargs):
            frame = func(self, *args, **kwargs)
            frame = MLFrame(frame)
            frame.model = self.model
            return frame
        return inner

    @wrapper
    def drop(self, *args, **kwargs):
        return super(MLFrame, self).drop(*args, **kwargs)

    @wrapper
    def copy(self, *args, **kwargs):
        return super(MLFrame, self).copy(*args, **kwargs)
    
    @wrapper
    def wrap__getitem__(self, df):
        return df

    def __getitem__(self, key):
        &#34;&#34;&#34;Wrapper for get item [] so that it returns an
        MLFrame rather then a pd.DataFrame&#34;&#34;&#34;
        call = super().__getitem__(key)
        if isinstance(call, pd.DataFrame):
            return self.wrap__getitem__(call)
        else:
            return call

    def info(self, *args, **kwargs):
        print(&#34;Model is %s\n&#34; % self.model)
        return super(MLFrame, self).info(*args, **kwargs)

    def one_hot_encode(self,
                        columns=[],
                        drop_first=True,
                        verbose=True,
                        **kwargs):
        &#34;&#34;&#34;Makes a one hot encoded dataframe

        Parameters
        ----------------------------------------
        columns[list]::
            list of columns to one hot encode
            uses self.cat_cols() if not defined
        drop_first=True::
            whether to drop the first column or not
            to rid of multicollinearity
        verbose[bool]::
            Whether to print out the series or not
        kwargs{dict}::
            Arguments to send to pd.get_dummies
            see:
        https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html

        Returns
        ----------------------------------------
        encoded dataframe

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(verbose=False, inplace=True)
        &gt;&gt;&gt; # splitting car_name into model for categorizing
        &gt;&gt;&gt; df[&#39;model&#39;] = df[&#39;car_name&#39;].apply(
        &gt;&gt;&gt;     lambda x: x.split(&#39; &#39;)[0])
        &gt;&gt;&gt; df_ohe = df.one_hot_encode(columns=[&#39;model&#39;])
        Added categorical columns
        37 -&gt; model
        &#34;&#34;&#34;
        if not isinstance(columns, list):
            raise(AttributeError(&#39;%s not a list&#39; % columns))
        elif not columns:
            columns = self.cat_cols()
        df = MLFrame(pd.get_dummies(self,
                                    columns=columns,
                                    drop_first=drop_first,
                                    **kwargs))
        
        if verbose:
            print(&#34;Added categorical columns&#34;)
            count_dict = {}
            for col in self.columns:
                count = 0
                for col_ohe in df.columns:
                    if col in col_ohe:
                        count += 1
                if count &gt; 1:
                    count_dict[col] = count
            for col, num in sorted(count_dict.items(), 
                    key=lambda x: x[1]):
                print(num, &#39;-&gt;&#39;, col)
                                
        return df

    def find_outliers_IQR(self, col, verbose=True):
        &#34;&#34;&#34;Finds outliers using the IQR method

        Parameters
        ----------------------------------------
        col[str]::
            Name of the column to search for outliers in
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        True/False Series of the outliers (True is outlier)

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; idx_outliers = df.find_outliers_IQR(&#39;horsepower&#39;, verbose=True)
        Found 10 outliers using IQR in horsepower or ~ 2.55%
        &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
        &#34;&#34;&#34;
        data = self[col]
        res = data.describe()
        IQR = res[&#39;75%&#39;]-res[&#39;25%&#39;]
        thresh = 1.5* IQR
        idx_outliers = ((data&lt;res[&#39;25%&#39;]-thresh)
                         | (data &gt; res[&#39;75%&#39;]+thresh))
        if verbose:
            total = idx_outliers.sum()
            total_perc = round((total/len(self))*100, 2)
            print(&#34;Found {} outliers using IQR in {} or ~ {}%&#34;
                  .format(total, col, total_perc))
        return idx_outliers

    def find_outliers_Z(self, col, verbose=True):
        &#34;&#34;&#34;Finds outliers using the z_score method
        ----------------------------------------
        col[str]::
            Name of the column to search for outliers in
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        True/False Series of the outliers (True is outlier)

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; idx_outliers = df.find_outliers_Z(&#39;horsepower&#39;, verbose=True)
        Found 5 outliers using z_score in horsepower or ~ 1.28%
        &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
        &#34;&#34;&#34;
        data = self[col]
        z_scores = np.abs(stats.zscore(data))
        z_scores = pd.Series(z_scores, index=data.index)
        idx_outliers =z_scores &gt; 3
        if verbose:
            total = idx_outliers.sum()
            total_perc = round((total/len(self))*100, 2)
            print(&#34;Found {} outliers using z_score in {} or ~ {}%&#34;
                  .format(total, col, total_perc))
        return idx_outliers    

    def outlier_removal(self,
                        columns=[],
                        IQR=False,
                        z_score=False,
                        verbose=True):
        &#34;&#34;&#34;Removes outliers based on IQR or z_score

        Parameters
        ----------------------------------------
        column[list, str]::
            The columns of which to remove outliers
            if blank, removes from all columns
        IQR[bool]::
            Whether or not to remove outliers
            using IQR method
        z_score[bool]::
            Whether or not to remove outliers
            using z_score method
        verbose[bool]::
            Whether to print how many outliers were
            found in each column or now       

        Returns
        ----------------------------------------
        Copy of dataframe with outliers removed

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df = df.outlier_removal(&#39;horsepower&#39;,
        ...                          IQR=True)
        Found 10 outliers using IQR in horsepower or ~ 2.55%
        Removed
        &gt;&gt;&gt; # OR
        &gt;&gt;&gt; df = df.outlier_removal([&#39;horsepower&#39;, &#39;mpg&#39;], 
                                 z_score=True)
        Found 10 outliers using z_score in horsepower or ~ 2.55%
        Removed
        Found 0 outliers using z_score in mpg or ~ 0.0%
        Removed
        &#34;&#34;&#34;
        if IQR:
            func = partial(self.find_outliers_IQR,
                           verbose=verbose)
        elif z_score:
            func = partial(self.find_outliers_Z,
                           verbose=verbose)
        try:
            func
        except UnboundLocalError:
            msg = &#34;No method defined, try z_score=True, or IQR=True&#34;
            raise AttributeError(msg)
        df = self.copy()
        if isinstance(columns, list):
            if not columns:
                columns = self.columns
            for col in columns:
                outliers = func(col)
                num = len(df)
                df = df[~outliers]
                if verbose:
                    print(&#39;Removed&#39;)
        else:
            outliers = func(columns)
            df = df[~outliers]
            if verbose:
                print(&#39;Removed&#39;)
        return df

    def get_nulls(self, verbose=True):
        &#34;&#34;&#34;Returns sum of all nulls in the dataframe

        Parameters
        ----------------------------------------
        verbose[bool]::
            Whether to print out the null count of
            each row or not

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.get_nulls(verbose=False)
        3
        &#34;&#34;&#34;
        nulls = self.isna().sum()
        if verbose:
            print(nulls.sort_values(ascending=True))
        nulls = nulls.sum()
        return nulls

    def drop_nulls_perc(self, perc,
                        inplace=False,
                        verbose=True):
        &#34;&#34;&#34;Drops a column if the null value is over a
        certain percentage (0-1)

        Parameters
        ----------------------------------------
        perc::[float]
            The percentage under which nulls are for a column
            to get dropped
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with columns dropped

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.drop_nulls_perc(.4)
            B   C   D
        0  NaN   2   3
        1  5.0   6   7
        2  9.0  10  11
        &#34;&#34;&#34;
        nulls = self.isna().sum()
        drop_cols = nulls[nulls/len(self) &gt; perc].index
        if verbose:
            print(&#39;Dropping: &#39;)
            for col in drop_cols:
                print(&#39;    --&gt; &#39;, col)
        return self.drop(columns=drop_cols, inplace=inplace)

    def ms_matrix(self, **kwargs):
        &#34;&#34;&#34;Plots a missingno matrix

        Parameters
        ----------------------------------------
        kwargs{dict}::
            Arguments to send to ms.matrix
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.ms_matrix()

        &#34;&#34;&#34;
        return ms.matrix(self, **kwargs)

    def fill_na_mode(self, inplace=False, verbose=True):
        &#34;&#34;&#34;Fills na cells with the mode of it&#39;s
        respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe.
        verbose[bool]::
            Whether to print out the filling information
            or not.

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mode

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.fill_na_mode()
        Filling 66.67% of A with nan
        Filling 33.33% of B with 9.0
            A    B    C   D
        0  0.0  5.0   2   3
        1  0.0  5.0   6   7
        2  0.0  9.0  10  11

        &#34;&#34;&#34;
        nulls = self.isna().sum()
        null_perc = nulls[nulls&gt;0]/len(self)
        null_cols = list(null_perc.index)
        null_modes = dict(self[null_cols].mode())
        if verbose:
            for col, perc in null_perc.items():
                print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                      &#34;\b%&#34;, &#34;of %s with %s&#34;
                    % (col, null_modes[col]))
        if inplace:
            for col, mode in null_modes.items():
                self[col] = self[col].fillna(mode[0])
        else:
            df = self.copy()
            for col, mode in null_modes.items():
                df[col] = df[col].fillna(mode[0])
            return df

    def fill_na_mean(self, inplace=False, verbose=True):
        &#34;&#34;&#34;Fills na cells with the mean of it&#39;s
        respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe.
        verbose[bool]::
            Whether to print out the filling information
            or not.

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mean

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.fill_na_mean()
        Filling 66.67% of A with nan
        Filling 33.33% of B with 9.0
            A    B    C   D
        0  0.0  7.0   2   3
        1  0.0  5.0   6   7
        2  0.0  9.0  10  11

        &#34;&#34;&#34;
        nulls = self.isna().sum()
        null_perc = nulls[nulls&gt;0]/len(self)
        null_cols = list(null_perc.index)
        null_means = dict(self[null_cols].mean())
        if verbose:
            for col, perc in null_perc.items():
                print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                      &#34;\b%&#34;, &#34;of %s with %s&#34;
                    % (col, null_means[col]))
        if inplace:
            for col, mean in null_means.items():
                self[col] = self[col].fillna(mean)
        else:
            df = self.copy()
            for col, mean in null_means.items():
                df[col] = df[col].fillna(mean)
            return df

    def fill_na_perc(self, inplace=False, verbose=True):
        &#34;&#34;&#34;
        * Not implemented *
        Fills na cells with the percent value_counts
        of it&#39;s respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out how many were filled
            in each column or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mode

        Example Usage
        ----------------------------------------
        &#34;&#34;&#34;
        raise AttributeError(&#39;Not Implemented&#39;)

    def qq_plot(self, **kwargs):
        &#34;&#34;&#34;Plots a statsmodels QQplot of the dataframe

        Parameters
        ----------------------------------------
        kwargs{dict}::
            Arguments to send to sm.graphics.qqplot()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.graphics.gofplots.qqplot.html

        Returns
        ----------------------------------------
        sm.graphics.qqplot()

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
        &gt;&gt;&gt; df.qq_plot()
        &#34;&#34;&#34;
        if self.model:
            if &#39;ax&#39; in kwargs:
                kwargs[&#39;ax&#39;].set_title(&#39;Model Residual QQ plot&#39;)
            return sm.graphics.qqplot(self.model.resid,
                        fit=True, line=&#39;45&#39;, **kwargs)
        else:
            raise AttributeError(&#39;No model defined&#39;)

    def model_resid_scatter(self, target, ax=None,
                            title=&#39;&#39;,
                            scatter_kws={}, line_kws={}):
        &#34;&#34;&#34;Plots a scatter plot and axhline 
        based on target and the model&#39;s residuals

        Parameters
        ----------------------------------------
        target[str]::
            The target of the model
        title[str]::
            The title of the plot
        ax[matplotlib.axes]:
            The axis to plot onto
        scatter_kws{dict}::
            Arguments to send to the scatter plot
            see:
        https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.scatter.html
        line_kws{dict}::
            Arguments to send to the axhline
            see:
        https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.axhline.html

        Returns
        ----------------------------------------
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
        &gt;&gt;&gt; df.model_resid_scatter(&#39;mpg&#39;)
        &#34;&#34;&#34;
        if ax:
            ax.set_title(title)
            ax.scatter(x=self[target],
                       y=self.model.resid,
                       **scatter_kws)
            ax.axhline(0, **line_kws)
            ax.set_xlabel(target)
            ax.set_ylabel(&#39;Model Residuals&#39;)
        else:
            plt.title(title)
            plt.scatter(self[target],
                        self.model.resid,
                        **scatter_kws)
            plt.axhline(0, **line_kws)
            plt.xlabel(target)
            plt.ylabel(&#39;Model Residuals&#39;)
            plt.show()

    def lrmodel(self,
                 target=None,
                 columns=[],
                 inplace=False,
                 verbose=True,
                 **kwargs):
        &#34;&#34;&#34;Creates a LinearRegression model of target

        Parameters
        ----------------------------------------
        target::[str]
            The target for which to model on
        cols[list]::
            a list of columns of which to build the model
            on.  If empty, uses all columns-target
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether or not to display the model.summary()
        kwargs{dict}::
            Arguments that are sent to Model.from_formula()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

        Returns
        ----------------------------------------
        None if inplace, otherwise returns the model

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, verbose=False, inplace=True)
        &gt;&gt;&gt; df.model.pvalues.max()
        0.9996627853521083
        &#34;&#34;&#34;
        if not target:
            raise AttributeError(&#39;No target defined&#39;)
        if not columns:
            columns = self.drop(target, axis=1).columns
        cols_form = &#39;+&#39;.join(columns)
        # cols_form = cols_form.replace(&#39; &#39;, &#39;&#39;)
        formula=&#39;%s~%s&#39; % (target, cols_form)
        # possibly svd did not converge here
        kwds = dict(formula=formula, data=self)
        kwds.update(**kwargs)
        model = smf.ols(**kwds).fit()
        try:  # undefined if used outside jupyter
            if verbose:
                display(model.summary())
        except NameError:
            print(model.summary())
        
        if inplace:
            self.model = model
        else:
            return model

    def model_and_plot(self,
                      target,
                      figsize=(10, 10),
                      **kwargs):
        &#34;&#34;&#34;Creates a new model based on target, plots a
        scatter plot of (target, model residuals), and
        plots a qqplot based on the model residuals.

        Parameters
        ----------------------------------------
        target::[str]
            The target for which to model on
        kwargs{dict}::
            Arguments that are sent to Model.from_formula()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

        Returns
        ----------------------------------------
        model

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.model_and_plot(&#39;mpg&#39;)
        &#34;&#34;&#34;
        self.lrmodel(target=target, inplace=True, verbose=True, **kwargs)
        model = self.model
        fig, axes = plt.subplots(nrows=2, figsize=figsize)
        fig.tight_layout(pad=8.0)
        self.qq_plot(ax=axes[0])
        self.model_resid_scatter(target, ax=axes[1],
            title=&#39;Model Residual Scatter plot&#39;,
            line_kws=dict(color=&#39;k&#39;))
        return model
        

    def plot_corr(self, figsize=(25, 25), annot=False,
                  **kwargs):
        &#34;&#34;&#34;Plots a predefined correlation heatmap

        Parameters
        ----------------------------------------
        figsize(tu, ple)::
            The size of the plotted figure
        annot[bool]::
            Whether or not to annotate the cells
        kwargs{dict}::
            Arguments that are sent to sns.heatmap
            see:
        https://seaborn.pydata.org/generated/seaborn.heatmap.html

        Returns
        ----------------------------------------
        fig, ax
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
        &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
        &gt;&gt;&gt; df.plot_corr(annot=True)
        &#34;&#34;&#34;
        corr=np.abs(self.corr())
        fig, ax = plt.subplots(figsize=figsize)
        mask=np.zeros_like(corr, dtype=np.bool)
        mask[np.triu_indices_from(mask, k=0)] = True
        kwds = dict(mask=mask,
                    cmap=sns.diverging_palette(240, 10, n=10),
                    annot=annot,
                    center=0,
                    ax=ax,
                    linewidths=1,
                    square=True,
                    cbar_kws={&#39;shrink&#39;:0.6})
        kwds.update(**kwargs)
        sns.heatmap(corr, **kwds)
        return fig, ax

    # needs testing, has to have a model before
    def plot_coef(self, cmap=&#39;Greens&#39;):
        &#34;&#34;&#34;Plots a predefined plot
        of the model&#39;s coefficients

        cmap[str]:: Default is Greens
            The style.background_gradient color
            see:
        https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html

        Returns
        ----------------------------------------
        &lt;pandas.io.formats.style.Styler&gt;
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
        &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
        &gt;&gt;&gt; df.plot_coef()
        &#34;&#34;&#34;
        coeffs = self.model.params.sort_values(ascending=False)
        frame = coeffs.to_frame(&#39;Coefficients&#39;)
        styler = frame.style.background_gradient(cmap=cmap)
        return styler

    def regplot(self, x, y, **kwargs):
        &#34;&#34;&#34;Plots a seaborn regplot of x and y

        Parameters
        ----------------------------------------
        x[str]::
            Name of a column to plot x
        y[str]::
            Name of a column to plot y
        kwargs{dict}::
            Arguments that are sent to sns.regplot
            see:
        https://seaborn.pydata.org/generated/seaborn.regplot.html

        Returns
        ----------------------------------------
        an sns.regplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.regplot(&#39;horsepower&#39;, &#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.regplot(x, y, data=self, **kwargs)

    def distplot(self, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn displot of target
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to plot
        kwargs{dict}::
            Arguments to send in with sns.distplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.distplot.html
            
        
        Returns
        ----------------------------------------
        an sns.distplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.distplot(&#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.distplot(self[target], **kwargs)

    def jointplot(self, x, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn jointplot of x and target
        Parameters
        ----------------------------------------
        x[str]::
            Name of a column to plot x
        target[str]::
            Name of the column of which to target
        kwargs{dict}::
            Arguments to send in with sns.jointplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.jointplot.html
        
        Returns
        ----------------------------------------
        an sns.jointplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.jointplot(&#39;horsepower&#39;, &#39;mpg&#39;)
        &#34;&#34;&#34;
        return sns.jointplot(data=self, x=x, y=target, **kwargs)

    def boxplot(self, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn boxplot of target
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to plot
        kwargs{dict}::
            Arguments to send in with sns.boxplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.boxplot.html
        
        Returns
        ----------------------------------------
        an sns.boxplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.boxplot(&#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.boxplot(y=self[target], **kwargs)

    def get_r_squareds(self, verbose=True):
        &#34;&#34;&#34;
        Tests models price to each column in the dataframe.

        Parameters
        ----------------------------------------
        verbose[bool]::
            Whether to print out the series or not
        
        Returns
        ----------------------------------------
        sorted pd.Series of columns --&gt; r_squared&#34;&#34;&#34;
        r_squared = {}
        for col in self.columns:
            model = self.lrmodel(&#39;price&#39;, [col], verbose=False)
            r_squared[col] =  model.rsquared
        rs = pd.Series(r_squared).sort_values()
        if verbose:
            print(&#34;R Squareds&#34;)
            print(rs)
        return rs

    def train_test_split(self,
                         target,
                         test_size=100,
                         seed=42,
                         verbose=True):
        &#34;&#34;&#34;
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to target
        test_size[int]::
            How many times to run the train_test_split
        seed[int]::
            The random seed to use
        verbose[bool]::
            Whether or not to show the model and plots
        
        Returns
        ----------------------------------------
        model[sm.regression.linear_model.RegressionResultsWrapper]::
            The best model of the train_test_split
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.drop([&#39;car_name&#39;, &#39;origin&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; model = df.train_test_split(&#39;mpg&#39;,
                                        test_size=5,
                                        verbose=False)
        &gt;&gt;&gt; model.pvalues
        Intercept      0.005
        cylinders      0.503
        displacement   0.688
        horsepower     0.868
        weight         0.000
        acceleration   0.510
        model_year     0.000
        dtype: float64
        &#34;&#34;&#34;
        r2dict = {}
        r2scores = {}
        test_amount = test_size
        for x in range(0, test_amount):
            np.random.seed(seed)
            choices = [.3, .2, .1, .05]
            c = np.random.choice(choices)
            # X = self.drop(target, axis=1).copy()
            # y = self[target].copy()
            df_train, df_test = train_test_split(
                                    self,
                                    test_size=c,
                                    random_state=seed)
            df_train = MLFrame(df_train)
            df_test = MLFrame(df_test)

            model = df_train.lrmodel(target, verbose=False)
            r2dict.update({model.rsquared:(
                model, df_train[target], c)})
            y_train = model.predict(df_train)
            y_test = model.predict(df_test)
            r2_train = r2_score(df_train[target],y_train)
            r2_test = r2_score(df_test[target],y_test)
        model, X, test_size = sorted(r2dict.items(),
                                  key=lambda x: x[0])[-1][1]
        
        self.model = model
        fig, axes = plt.subplots(nrows=2, figsize=(10, 10))
        fig.tight_layout(pad=8.0)
        self.qq_plot(ax=axes[0])
        axes[1].scatter(X, self.model.resid)
        axes[1].axhline(0, color=&#39;k&#39;)
        axes[1].set_xlabel(target)
        axes[1].set_ylabel(&#39;Model Residuals&#39;)
        if verbose:
            print(&#39;test_size = &#39;, test_size)
            try:
                display(model.summary())
            except NameError:
                print(model.summary())
            plt.show()
        return model


def test_car():
    df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    df.clean_col_names(inplace=True)
    df[&#39;model&#39;] = df[&#39;car_name&#39;].apply(lambda x: x.split(&#39; &#39;)[0])
    df.drop([&#39;car_name&#39;], axis=1, inplace=True)
    df[&#39;model&#39;] = df[&#39;model&#39;].astype(&#39;category&#39;)
    df_ohe = df.one_hot_encode([&#39;model&#39;])
    df_ohe.clean_col_names(inplace=True)
    df_ohe.model_and_plot(&#39;horsepower&#39;, inplace=True)
    print(df_ohe.model.summary())

def test_houses():
    df = MLFrame(pd.read_csv(&#39;kc_house_data.csv&#39;))
    first_model = df.fill_na_mode(  # Fill na for the model
        ).drop([&#39;date&#39;, &#39;sqft_basement&#39;], axis=1  # Dropping date and
        ).model_and_plot(&#39;price&#39;)                 # sqft_basement for example
    #df.model = first_model
    #df.plot_coef()
    #df.plot_corr(annot=True)
    df[&#39;sqft_basement&#39;] = df[&#39;sqft_basement&#39;].apply(
        lambda x: 0 if x == &#39;?&#39; else x)
    df[&#39;sqft_basement&#39;] = df[&#39;sqft_basement&#39;].astype(float)
    cat_cols = [&#39;zipcode&#39;, &#39;condition&#39;, &#39;view&#39;]
    for col in cat_cols:
        df[col] = df[col].astype(&#39;category&#39;)
    df_ohe = df.drop([&#39;date&#39;, &#39;id&#39;, &#39;lat&#39;, &#39;long&#39;], axis=1
        ).one_hot_encode(cat_cols)
    df_ohe[&#39;waterfront&#39;].fillna(0, inplace=True)
    df_ohe.fill_na_mode(inplace=True)
    drop_cols = [x for x in df_ohe.columns if &#39;condition&#39; in x]
    drop_cols.append(&#39;sqft_living&#39;)
    df_ohe.drop(drop_cols, axis=1, inplace=True)
    df_ohe.clean_col_names(inplace=True)
    df_ohe.model_and_plot(&#39;price&#39;)
    print(df_ohe.model.summary())


if __name__ == &#34;__main__&#34;:
    test_houses()
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mlframe.mlframe.inherit_docstrings"><code class="name flex">
<span>def <span class="ident">inherit_docstrings</span></span>(<span>cls)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_docstrings(cls):
    for name, func in getmembers(cls, isfunction):
        if func.__doc__: continue
        for parent in cls.__mro__[1:]:
            if hasattr(parent, name):
                func.__doc__ = getattr(parent, name).__doc__
    return cls</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.test_car"><code class="name flex">
<span>def <span class="ident">test_car</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_car():
    df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    df.clean_col_names(inplace=True)
    df[&#39;model&#39;] = df[&#39;car_name&#39;].apply(lambda x: x.split(&#39; &#39;)[0])
    df.drop([&#39;car_name&#39;], axis=1, inplace=True)
    df[&#39;model&#39;] = df[&#39;model&#39;].astype(&#39;category&#39;)
    df_ohe = df.one_hot_encode([&#39;model&#39;])
    df_ohe.clean_col_names(inplace=True)
    df_ohe.model_and_plot(&#39;horsepower&#39;, inplace=True)
    print(df_ohe.model.summary())</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.test_houses"><code class="name flex">
<span>def <span class="ident">test_houses</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_houses():
    df = MLFrame(pd.read_csv(&#39;kc_house_data.csv&#39;))
    first_model = df.fill_na_mode(  # Fill na for the model
        ).drop([&#39;date&#39;, &#39;sqft_basement&#39;], axis=1  # Dropping date and
        ).model_and_plot(&#39;price&#39;)                 # sqft_basement for example
    #df.model = first_model
    #df.plot_coef()
    #df.plot_corr(annot=True)
    df[&#39;sqft_basement&#39;] = df[&#39;sqft_basement&#39;].apply(
        lambda x: 0 if x == &#39;?&#39; else x)
    df[&#39;sqft_basement&#39;] = df[&#39;sqft_basement&#39;].astype(float)
    cat_cols = [&#39;zipcode&#39;, &#39;condition&#39;, &#39;view&#39;]
    for col in cat_cols:
        df[col] = df[col].astype(&#39;category&#39;)
    df_ohe = df.drop([&#39;date&#39;, &#39;id&#39;, &#39;lat&#39;, &#39;long&#39;], axis=1
        ).one_hot_encode(cat_cols)
    df_ohe[&#39;waterfront&#39;].fillna(0, inplace=True)
    df_ohe.fill_na_mode(inplace=True)
    drop_cols = [x for x in df_ohe.columns if &#39;condition&#39; in x]
    drop_cols.append(&#39;sqft_living&#39;)
    df_ohe.drop(drop_cols, axis=1, inplace=True)
    df_ohe.clean_col_names(inplace=True)
    df_ohe.model_and_plot(&#39;price&#39;)
    print(df_ohe.model.summary())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mlframe.mlframe.MLFrame"><code class="flex name class">
<span>class <span class="ident">MLFrame</span></span>
<span>(</span><span>frame, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A pd.DataFrame with an inplace model, and LinearRegression
modeling functions.</p>
<p>**See pandas.DataFrame documentation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MLFrame(pd.DataFrame):
    &#34;&#34;&#34;A pd.DataFrame with an inplace model, and LinearRegression
    modeling functions.
    
    **See pandas.DataFrame documentation&#34;&#34;&#34;
    model = None

    def __init__(self, frame, **kwargs):
        super(MLFrame, self).__init__(frame, **kwargs)

    def cat_cols(self):
        &#34;&#34;&#34;Computes and returns Categorical columns&#34;&#34;&#34;
        return list(self.select_dtypes(&#39;object&#39;).columns)

    def num_cols(self):
        &#34;&#34;&#34;Computes and returns Numerical columns&#34;&#34;&#34;
        return list(self.select_dtypes(&#39;number&#39;).columns)

    @staticmethod
    def replace_all(string):
        &#34;&#34;&#34;Replaces bad characters in a string for
        column names to work in a R~formula&#34;&#34;&#34;
        return string.replace(
                      &#39; &#39;, &#39;_&#39;).replace(
                      &#39;(&#39;, &#39;&#39;).replace(
                      &#39;)&#39;, &#39;&#39;).replace(
                    #   &#39;1&#39;, &#39;one&#39;).replace(
                    #   &#39;2&#39;, &#39;two&#39;).replace(
                    #   &#39;3&#39;, &#39;three&#39;).replace(
                    #   &#39;4&#39;, &#39;four&#39;).replace(
                    #   &#39;5&#39;, &#39;five&#39;).replace(
                    #   &#39;6&#39;, &#39;six&#39;).replace(
                    #   &#39;7&#39;, &#39;seven&#39;).replace(
                    #   &#39;8&#39;, &#39;eight&#39;).replace(
                    #   &#39;9&#39;, &#39;nine&#39;).replace(
                      &#39;.&#39;, &#39;_&#39;).replace(
                      &#39;-&#39;, &#39;_&#39;).replace(
                      &#39;/&#39;, &#39;_&#39;).replace(
                      &#39;@&#39;, &#39;_&#39;).replace(
                      &#39;+&#39;, &#39;_&#39;).replace(
                      &#39; &#39;, &#39;_&#39;).replace(
                      &#39; &#39;, &#39;_&#39;)

    def clean_col_names(self,
                        inplace=False,
                        verbose=True):
        &#34;&#34;&#34;Cleans the column names of a DataFrame
        for use in an R~Formula

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to show the difference between
            the old columns and clean columns or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns a copy of the dataframe

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names()
        Columns changed:
        model year --&gt; model_year
        car name --&gt; car_name
        &#34;&#34;&#34;
        def show_difference(old_cols, new_cols):
            diff = dict(zip(old_cols, new_cols))
            print(&#39;\nColumns changed:&#39;)
            for col in diff.items():
                if col[0] != col[1]:
                    print(col[0], &#34;--&gt;&#34;, col[1])

        if inplace:
            new_columns = [self.replace_all(c.strip())
                            for c in self.columns.values.tolist()]
            old_columns = self.columns
            if verbose:
                show_difference(old_columns, new_columns)
            self.columns = new_columns
        else:
            df = self.copy()
            new_columns = [self.replace_all(c.strip())
                            for c in df.columns.values.tolist()]
            old_columns = df.columns
            if verbose:
                show_difference(old_columns, new_columns)
            df.columns = new_columns
            return df

    def get_vif(self, target, verbose=True):
        &#34;&#34;&#34;Computes the Variance Inflation Factor
        for the columns of a dataframe based
        on the target column

        Parameters
        ----------------------------------------
        target[str]::
            The column name to base the VIF on
        verbose[bool]::
            Whether or not to print out the VIF series

        Returns
        ----------------------------------------
        Series of variance_inflation_factor for each column

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; df.get_vif(&#39;mpg&#39;, verbose=False)
        const          763.558
        cylinders       10.738
        displacement    21.837
        horsepower       9.944
        weight          10.831
        acceleration     2.626
        model year       1.245
        origin           1.772
        &#34;&#34;&#34;
        X = self.drop(target, axis=1)
        X = sm.add_constant(X)
        vif = [variance_inflation_factor(X.values, i)
            for i in range(X.shape[1])]
        s = pd.Series(dict(zip(X.columns, vif)))
        if verbose:
            print(s)
        return s

    def get_vif_cols(self, target, threshold=6, verbose=True,
                     inplace=False):
        &#34;&#34;&#34; Computes Variance Inflation Factor
        for the dataframe, and gets the columns
        that are above the defined threshold

        Parameters
        ----------------------------------------
        target[str]::
            The column name to base the VIF on
        threshold=6[int]::
            The threshold that columns would be above
            where they are an issue, and need to be
            looked at
        verbose[bool]::
            Whether to print out the series or not
        inplace[bool]::
            Whether to return the series or not

        Returns
        ----------------------------------------
        Depending on inplace
        Series of variance_inflation_factor for each column

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; df.get_vif_cols(&#39;mpg&#39;, verbose=False)
        horsepower      9.944
        cylinders      10.738
        weight         10.831
        displacement   21.837
        dtype: float64
        &#34;&#34;&#34;
        vif_results = self.get_vif(target, verbose=False)
        bad_vif = list(vif_results[vif_results&gt;threshold].index)
        if &#39;const&#39; in bad_vif:
            bad_vif.remove(&#39;const&#39;)
        num_vif = {}
        for col in bad_vif:
            num_vif[col] = vif_results[col]
        s = pd.Series(num_vif).sort_values()
        if verbose:
            print(&#39;\nVIF columns &gt; %s: \n%s&#39;
                  % (threshold, s))
        if not inplace:
            return s

    def log(self, columns, inplace=False, verbose=True):
        &#34;&#34;&#34; logs the listed columns of the dataframe
        Parameters
        ----------------------------------------
        columns[list, str]::
            A list of columns to make logarithmic
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out logged columns or not

        Returns
        ----------------------------------------
        None if inplace otherwise returns a copy
        of the dataframe with columns logged

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
        
        &gt;&gt;&gt; df = df.log(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
        Logging:
           mpg
           cylinders
        # OR
        &gt;&gt;&gt; df.log(&#39;mpg&#39;, inplace=True)
        Logging:
           mpg
        &#34;&#34;&#34;
        if verbose:
            print(&#34;\nLogging:&#34;)
            if isinstance(columns, list):
                for col in columns:
                    print(&#34;  &#34;, col)
            else:
                print(&#34;  &#34;, columns)
        if inplace:
            if isinstance(columns, list):
                for col in columns:
                    self[col] = np.log(self[col])
            else:
                self[columns] = np.log(self[columns])
        else:
            df = self.copy()
            if isinstance(columns, list):
                for col in columns:
                    df[col] = np.log(df[col])
            else:
                df[columns] = np.log(df[columns])
            return df

    def scale(self, columns, inplace=False, verbose=True):
        &#34;&#34;&#34; Scales the listed columns of the dataframe
        Parameters
        ----------------------------------------
        columns[list, str]::
            A list of columns to scale
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out the scaled columns or not

        Returns:
            None if inplace otherwise returns a copy
            of the dataframe with columns scaled

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
        
        &gt;&gt;&gt; df = df.scale(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
        Scaling:
           mpg
           cylinders
        # OR
        &gt;&gt;&gt; df.scale(&#39;mpg&#39;, inplace=True)
        Scaling:
           mpg
        &#34;&#34;&#34;
        def scale(df, col):
            df[col] = ((df[col] - np.mean(df[col]))
                      / np.sqrt(np.var(df[col])))
        if verbose:
            print(&#34;\nScaling:&#34;)
            if isinstance(columns, list):
                for col in columns:
                    print(&#34;  &#34;, col)
            else:
                print(&#34;  &#34;, columns)
        if inplace:
            if isinstance(columns, list):
                for col in columns:
                    scale(self, col)
            else:
                scale(self, columns)
        else:
            df = self.copy()
            if isinstance(columns, list):
                for col in columns:
                    scale(df, col)
            else:
                scale(df, columns)
            return df

    def wrapper(func):
        &#34;&#34;&#34;Wrapper to return a MLFrame, and set
        the model when defined pd.DataFrame methods
        are used on a MLFrame&#34;&#34;&#34;
        @wraps(func)
        @inherit_docstrings
        def inner(self, *args, **kwargs):
            frame = func(self, *args, **kwargs)
            frame = MLFrame(frame)
            frame.model = self.model
            return frame
        return inner

    @wrapper
    def drop(self, *args, **kwargs):
        return super(MLFrame, self).drop(*args, **kwargs)

    @wrapper
    def copy(self, *args, **kwargs):
        return super(MLFrame, self).copy(*args, **kwargs)
    
    @wrapper
    def wrap__getitem__(self, df):
        return df

    def __getitem__(self, key):
        &#34;&#34;&#34;Wrapper for get item [] so that it returns an
        MLFrame rather then a pd.DataFrame&#34;&#34;&#34;
        call = super().__getitem__(key)
        if isinstance(call, pd.DataFrame):
            return self.wrap__getitem__(call)
        else:
            return call

    def info(self, *args, **kwargs):
        print(&#34;Model is %s\n&#34; % self.model)
        return super(MLFrame, self).info(*args, **kwargs)

    def one_hot_encode(self,
                        columns=[],
                        drop_first=True,
                        verbose=True,
                        **kwargs):
        &#34;&#34;&#34;Makes a one hot encoded dataframe

        Parameters
        ----------------------------------------
        columns[list]::
            list of columns to one hot encode
            uses self.cat_cols() if not defined
        drop_first=True::
            whether to drop the first column or not
            to rid of multicollinearity
        verbose[bool]::
            Whether to print out the series or not
        kwargs{dict}::
            Arguments to send to pd.get_dummies
            see:
        https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html

        Returns
        ----------------------------------------
        encoded dataframe

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(verbose=False, inplace=True)
        &gt;&gt;&gt; # splitting car_name into model for categorizing
        &gt;&gt;&gt; df[&#39;model&#39;] = df[&#39;car_name&#39;].apply(
        &gt;&gt;&gt;     lambda x: x.split(&#39; &#39;)[0])
        &gt;&gt;&gt; df_ohe = df.one_hot_encode(columns=[&#39;model&#39;])
        Added categorical columns
        37 -&gt; model
        &#34;&#34;&#34;
        if not isinstance(columns, list):
            raise(AttributeError(&#39;%s not a list&#39; % columns))
        elif not columns:
            columns = self.cat_cols()
        df = MLFrame(pd.get_dummies(self,
                                    columns=columns,
                                    drop_first=drop_first,
                                    **kwargs))
        
        if verbose:
            print(&#34;Added categorical columns&#34;)
            count_dict = {}
            for col in self.columns:
                count = 0
                for col_ohe in df.columns:
                    if col in col_ohe:
                        count += 1
                if count &gt; 1:
                    count_dict[col] = count
            for col, num in sorted(count_dict.items(), 
                    key=lambda x: x[1]):
                print(num, &#39;-&gt;&#39;, col)
                                
        return df

    def find_outliers_IQR(self, col, verbose=True):
        &#34;&#34;&#34;Finds outliers using the IQR method

        Parameters
        ----------------------------------------
        col[str]::
            Name of the column to search for outliers in
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        True/False Series of the outliers (True is outlier)

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; idx_outliers = df.find_outliers_IQR(&#39;horsepower&#39;, verbose=True)
        Found 10 outliers using IQR in horsepower or ~ 2.55%
        &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
        &#34;&#34;&#34;
        data = self[col]
        res = data.describe()
        IQR = res[&#39;75%&#39;]-res[&#39;25%&#39;]
        thresh = 1.5* IQR
        idx_outliers = ((data&lt;res[&#39;25%&#39;]-thresh)
                         | (data &gt; res[&#39;75%&#39;]+thresh))
        if verbose:
            total = idx_outliers.sum()
            total_perc = round((total/len(self))*100, 2)
            print(&#34;Found {} outliers using IQR in {} or ~ {}%&#34;
                  .format(total, col, total_perc))
        return idx_outliers

    def find_outliers_Z(self, col, verbose=True):
        &#34;&#34;&#34;Finds outliers using the z_score method
        ----------------------------------------
        col[str]::
            Name of the column to search for outliers in
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        True/False Series of the outliers (True is outlier)

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; idx_outliers = df.find_outliers_Z(&#39;horsepower&#39;, verbose=True)
        Found 5 outliers using z_score in horsepower or ~ 1.28%
        &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
        &#34;&#34;&#34;
        data = self[col]
        z_scores = np.abs(stats.zscore(data))
        z_scores = pd.Series(z_scores, index=data.index)
        idx_outliers =z_scores &gt; 3
        if verbose:
            total = idx_outliers.sum()
            total_perc = round((total/len(self))*100, 2)
            print(&#34;Found {} outliers using z_score in {} or ~ {}%&#34;
                  .format(total, col, total_perc))
        return idx_outliers    

    def outlier_removal(self,
                        columns=[],
                        IQR=False,
                        z_score=False,
                        verbose=True):
        &#34;&#34;&#34;Removes outliers based on IQR or z_score

        Parameters
        ----------------------------------------
        column[list, str]::
            The columns of which to remove outliers
            if blank, removes from all columns
        IQR[bool]::
            Whether or not to remove outliers
            using IQR method
        z_score[bool]::
            Whether or not to remove outliers
            using z_score method
        verbose[bool]::
            Whether to print how many outliers were
            found in each column or now       

        Returns
        ----------------------------------------
        Copy of dataframe with outliers removed

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df = df.outlier_removal(&#39;horsepower&#39;,
        ...                          IQR=True)
        Found 10 outliers using IQR in horsepower or ~ 2.55%
        Removed
        &gt;&gt;&gt; # OR
        &gt;&gt;&gt; df = df.outlier_removal([&#39;horsepower&#39;, &#39;mpg&#39;], 
                                 z_score=True)
        Found 10 outliers using z_score in horsepower or ~ 2.55%
        Removed
        Found 0 outliers using z_score in mpg or ~ 0.0%
        Removed
        &#34;&#34;&#34;
        if IQR:
            func = partial(self.find_outliers_IQR,
                           verbose=verbose)
        elif z_score:
            func = partial(self.find_outliers_Z,
                           verbose=verbose)
        try:
            func
        except UnboundLocalError:
            msg = &#34;No method defined, try z_score=True, or IQR=True&#34;
            raise AttributeError(msg)
        df = self.copy()
        if isinstance(columns, list):
            if not columns:
                columns = self.columns
            for col in columns:
                outliers = func(col)
                num = len(df)
                df = df[~outliers]
                if verbose:
                    print(&#39;Removed&#39;)
        else:
            outliers = func(columns)
            df = df[~outliers]
            if verbose:
                print(&#39;Removed&#39;)
        return df

    def get_nulls(self, verbose=True):
        &#34;&#34;&#34;Returns sum of all nulls in the dataframe

        Parameters
        ----------------------------------------
        verbose[bool]::
            Whether to print out the null count of
            each row or not

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.get_nulls(verbose=False)
        3
        &#34;&#34;&#34;
        nulls = self.isna().sum()
        if verbose:
            print(nulls.sort_values(ascending=True))
        nulls = nulls.sum()
        return nulls

    def drop_nulls_perc(self, perc,
                        inplace=False,
                        verbose=True):
        &#34;&#34;&#34;Drops a column if the null value is over a
        certain percentage (0-1)

        Parameters
        ----------------------------------------
        perc::[float]
            The percentage under which nulls are for a column
            to get dropped
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out the series or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with columns dropped

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.drop_nulls_perc(.4)
            B   C   D
        0  NaN   2   3
        1  5.0   6   7
        2  9.0  10  11
        &#34;&#34;&#34;
        nulls = self.isna().sum()
        drop_cols = nulls[nulls/len(self) &gt; perc].index
        if verbose:
            print(&#39;Dropping: &#39;)
            for col in drop_cols:
                print(&#39;    --&gt; &#39;, col)
        return self.drop(columns=drop_cols, inplace=inplace)

    def ms_matrix(self, **kwargs):
        &#34;&#34;&#34;Plots a missingno matrix

        Parameters
        ----------------------------------------
        kwargs{dict}::
            Arguments to send to ms.matrix
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.ms_matrix()

        &#34;&#34;&#34;
        return ms.matrix(self, **kwargs)

    def fill_na_mode(self, inplace=False, verbose=True):
        &#34;&#34;&#34;Fills na cells with the mode of it&#39;s
        respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe.
        verbose[bool]::
            Whether to print out the filling information
            or not.

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mode

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.fill_na_mode()
        Filling 66.67% of A with nan
        Filling 33.33% of B with 9.0
            A    B    C   D
        0  0.0  5.0   2   3
        1  0.0  5.0   6   7
        2  0.0  9.0  10  11

        &#34;&#34;&#34;
        nulls = self.isna().sum()
        null_perc = nulls[nulls&gt;0]/len(self)
        null_cols = list(null_perc.index)
        null_modes = dict(self[null_cols].mode())
        if verbose:
            for col, perc in null_perc.items():
                print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                      &#34;\b%&#34;, &#34;of %s with %s&#34;
                    % (col, null_modes[col]))
        if inplace:
            for col, mode in null_modes.items():
                self[col] = self[col].fillna(mode[0])
        else:
            df = self.copy()
            for col, mode in null_modes.items():
                df[col] = df[col].fillna(mode[0])
            return df

    def fill_na_mean(self, inplace=False, verbose=True):
        &#34;&#34;&#34;Fills na cells with the mean of it&#39;s
        respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe.
        verbose[bool]::
            Whether to print out the filling information
            or not.

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mean

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
        &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
        &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
        &gt;&gt;&gt; df
            A    B   C   D
        0  0.0  NaN   2   3
        1  NaN  5.0   6   7
        2  NaN  9.0  10  11
        &gt;&gt;&gt; df.fill_na_mean()
        Filling 66.67% of A with nan
        Filling 33.33% of B with 9.0
            A    B    C   D
        0  0.0  7.0   2   3
        1  0.0  5.0   6   7
        2  0.0  9.0  10  11

        &#34;&#34;&#34;
        nulls = self.isna().sum()
        null_perc = nulls[nulls&gt;0]/len(self)
        null_cols = list(null_perc.index)
        null_means = dict(self[null_cols].mean())
        if verbose:
            for col, perc in null_perc.items():
                print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                      &#34;\b%&#34;, &#34;of %s with %s&#34;
                    % (col, null_means[col]))
        if inplace:
            for col, mean in null_means.items():
                self[col] = self[col].fillna(mean)
        else:
            df = self.copy()
            for col, mean in null_means.items():
                df[col] = df[col].fillna(mean)
            return df

    def fill_na_perc(self, inplace=False, verbose=True):
        &#34;&#34;&#34;
        * Not implemented *
        Fills na cells with the percent value_counts
        of it&#39;s respective column

        Parameters
        ----------------------------------------
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether to print out how many were filled
            in each column or not

        Returns
        ----------------------------------------
        None if inplace, otherwise returns copy of dataframe
        with nulls filled with mode

        Example Usage
        ----------------------------------------
        &#34;&#34;&#34;
        raise AttributeError(&#39;Not Implemented&#39;)

    def qq_plot(self, **kwargs):
        &#34;&#34;&#34;Plots a statsmodels QQplot of the dataframe

        Parameters
        ----------------------------------------
        kwargs{dict}::
            Arguments to send to sm.graphics.qqplot()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.graphics.gofplots.qqplot.html

        Returns
        ----------------------------------------
        sm.graphics.qqplot()

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
        &gt;&gt;&gt; df.qq_plot()
        &#34;&#34;&#34;
        if self.model:
            if &#39;ax&#39; in kwargs:
                kwargs[&#39;ax&#39;].set_title(&#39;Model Residual QQ plot&#39;)
            return sm.graphics.qqplot(self.model.resid,
                        fit=True, line=&#39;45&#39;, **kwargs)
        else:
            raise AttributeError(&#39;No model defined&#39;)

    def model_resid_scatter(self, target, ax=None,
                            title=&#39;&#39;,
                            scatter_kws={}, line_kws={}):
        &#34;&#34;&#34;Plots a scatter plot and axhline 
        based on target and the model&#39;s residuals

        Parameters
        ----------------------------------------
        target[str]::
            The target of the model
        title[str]::
            The title of the plot
        ax[matplotlib.axes]:
            The axis to plot onto
        scatter_kws{dict}::
            Arguments to send to the scatter plot
            see:
        https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.scatter.html
        line_kws{dict}::
            Arguments to send to the axhline
            see:
        https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.axhline.html

        Returns
        ----------------------------------------
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
        &gt;&gt;&gt; df.model_resid_scatter(&#39;mpg&#39;)
        &#34;&#34;&#34;
        if ax:
            ax.set_title(title)
            ax.scatter(x=self[target],
                       y=self.model.resid,
                       **scatter_kws)
            ax.axhline(0, **line_kws)
            ax.set_xlabel(target)
            ax.set_ylabel(&#39;Model Residuals&#39;)
        else:
            plt.title(title)
            plt.scatter(self[target],
                        self.model.resid,
                        **scatter_kws)
            plt.axhline(0, **line_kws)
            plt.xlabel(target)
            plt.ylabel(&#39;Model Residuals&#39;)
            plt.show()

    def lrmodel(self,
                 target=None,
                 columns=[],
                 inplace=False,
                 verbose=True,
                 **kwargs):
        &#34;&#34;&#34;Creates a LinearRegression model of target

        Parameters
        ----------------------------------------
        target::[str]
            The target for which to model on
        cols[list]::
            a list of columns of which to build the model
            on.  If empty, uses all columns-target
        inplace[bool]::
            Defines whether to return a new dataframe or
            mutate the dataframe
        verbose[bool]::
            Whether or not to display the model.summary()
        kwargs{dict}::
            Arguments that are sent to Model.from_formula()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

        Returns
        ----------------------------------------
        None if inplace, otherwise returns the model

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, verbose=False, inplace=True)
        &gt;&gt;&gt; df.model.pvalues.max()
        0.9996627853521083
        &#34;&#34;&#34;
        if not target:
            raise AttributeError(&#39;No target defined&#39;)
        if not columns:
            columns = self.drop(target, axis=1).columns
        cols_form = &#39;+&#39;.join(columns)
        # cols_form = cols_form.replace(&#39; &#39;, &#39;&#39;)
        formula=&#39;%s~%s&#39; % (target, cols_form)
        # possibly svd did not converge here
        kwds = dict(formula=formula, data=self)
        kwds.update(**kwargs)
        model = smf.ols(**kwds).fit()
        try:  # undefined if used outside jupyter
            if verbose:
                display(model.summary())
        except NameError:
            print(model.summary())
        
        if inplace:
            self.model = model
        else:
            return model

    def model_and_plot(self,
                      target,
                      figsize=(10, 10),
                      **kwargs):
        &#34;&#34;&#34;Creates a new model based on target, plots a
        scatter plot of (target, model residuals), and
        plots a qqplot based on the model residuals.

        Parameters
        ----------------------------------------
        target::[str]
            The target for which to model on
        kwargs{dict}::
            Arguments that are sent to Model.from_formula()
            see:
        https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

        Returns
        ----------------------------------------
        model

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.model_and_plot(&#39;mpg&#39;)
        &#34;&#34;&#34;
        self.lrmodel(target=target, inplace=True, verbose=True, **kwargs)
        model = self.model
        fig, axes = plt.subplots(nrows=2, figsize=figsize)
        fig.tight_layout(pad=8.0)
        self.qq_plot(ax=axes[0])
        self.model_resid_scatter(target, ax=axes[1],
            title=&#39;Model Residual Scatter plot&#39;,
            line_kws=dict(color=&#39;k&#39;))
        return model
        

    def plot_corr(self, figsize=(25, 25), annot=False,
                  **kwargs):
        &#34;&#34;&#34;Plots a predefined correlation heatmap

        Parameters
        ----------------------------------------
        figsize(tu, ple)::
            The size of the plotted figure
        annot[bool]::
            Whether or not to annotate the cells
        kwargs{dict}::
            Arguments that are sent to sns.heatmap
            see:
        https://seaborn.pydata.org/generated/seaborn.heatmap.html

        Returns
        ----------------------------------------
        fig, ax
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
        &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
        &gt;&gt;&gt; df.plot_corr(annot=True)
        &#34;&#34;&#34;
        corr=np.abs(self.corr())
        fig, ax = plt.subplots(figsize=figsize)
        mask=np.zeros_like(corr, dtype=np.bool)
        mask[np.triu_indices_from(mask, k=0)] = True
        kwds = dict(mask=mask,
                    cmap=sns.diverging_palette(240, 10, n=10),
                    annot=annot,
                    center=0,
                    ax=ax,
                    linewidths=1,
                    square=True,
                    cbar_kws={&#39;shrink&#39;:0.6})
        kwds.update(**kwargs)
        sns.heatmap(corr, **kwds)
        return fig, ax

    # needs testing, has to have a model before
    def plot_coef(self, cmap=&#39;Greens&#39;):
        &#34;&#34;&#34;Plots a predefined plot
        of the model&#39;s coefficients

        cmap[str]:: Default is Greens
            The style.background_gradient color
            see:
        https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html

        Returns
        ----------------------------------------
        &lt;pandas.io.formats.style.Styler&gt;
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
        &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
        &gt;&gt;&gt; df.plot_coef()
        &#34;&#34;&#34;
        coeffs = self.model.params.sort_values(ascending=False)
        frame = coeffs.to_frame(&#39;Coefficients&#39;)
        styler = frame.style.background_gradient(cmap=cmap)
        return styler

    def regplot(self, x, y, **kwargs):
        &#34;&#34;&#34;Plots a seaborn regplot of x and y

        Parameters
        ----------------------------------------
        x[str]::
            Name of a column to plot x
        y[str]::
            Name of a column to plot y
        kwargs{dict}::
            Arguments that are sent to sns.regplot
            see:
        https://seaborn.pydata.org/generated/seaborn.regplot.html

        Returns
        ----------------------------------------
        an sns.regplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.regplot(&#39;horsepower&#39;, &#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.regplot(x, y, data=self, **kwargs)

    def distplot(self, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn displot of target
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to plot
        kwargs{dict}::
            Arguments to send in with sns.distplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.distplot.html
            
        
        Returns
        ----------------------------------------
        an sns.distplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.distplot(&#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.distplot(self[target], **kwargs)

    def jointplot(self, x, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn jointplot of x and target
        Parameters
        ----------------------------------------
        x[str]::
            Name of a column to plot x
        target[str]::
            Name of the column of which to target
        kwargs{dict}::
            Arguments to send in with sns.jointplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.jointplot.html
        
        Returns
        ----------------------------------------
        an sns.jointplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.jointplot(&#39;horsepower&#39;, &#39;mpg&#39;)
        &#34;&#34;&#34;
        return sns.jointplot(data=self, x=x, y=target, **kwargs)

    def boxplot(self, target, **kwargs):
        &#34;&#34;&#34;Plots a seaborn boxplot of target
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to plot
        kwargs{dict}::
            Arguments to send in with sns.boxplot()
            see:
        https://seaborn.pydata.org/generated/seaborn.boxplot.html
        
        Returns
        ----------------------------------------
        an sns.boxplot

        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; fig, ax = plt.subplots()
        &gt;&gt;&gt; df.boxplot(&#39;mpg&#39;, ax=ax)
        &#34;&#34;&#34;
        return sns.boxplot(y=self[target], **kwargs)

    def get_r_squareds(self, verbose=True):
        &#34;&#34;&#34;
        Tests models price to each column in the dataframe.

        Parameters
        ----------------------------------------
        verbose[bool]::
            Whether to print out the series or not
        
        Returns
        ----------------------------------------
        sorted pd.Series of columns --&gt; r_squared&#34;&#34;&#34;
        r_squared = {}
        for col in self.columns:
            model = self.lrmodel(&#39;price&#39;, [col], verbose=False)
            r_squared[col] =  model.rsquared
        rs = pd.Series(r_squared).sort_values()
        if verbose:
            print(&#34;R Squareds&#34;)
            print(rs)
        return rs

    def train_test_split(self,
                         target,
                         test_size=100,
                         seed=42,
                         verbose=True):
        &#34;&#34;&#34;
        Parameters
        ----------------------------------------
        target[str]::
            Name of the column of which to target
        test_size[int]::
            How many times to run the train_test_split
        seed[int]::
            The random seed to use
        verbose[bool]::
            Whether or not to show the model and plots
        
        Returns
        ----------------------------------------
        model[sm.regression.linear_model.RegressionResultsWrapper]::
            The best model of the train_test_split
        
        Example Usage
        ----------------------------------------
        &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
        &gt;&gt;&gt; df.clean_col_names(inplace=True)
        &gt;&gt;&gt; df.drop([&#39;car_name&#39;, &#39;origin&#39;], axis=1, inplace=True)
        &gt;&gt;&gt; model = df.train_test_split(&#39;mpg&#39;,
                                        test_size=5,
                                        verbose=False)
        &gt;&gt;&gt; model.pvalues
        Intercept      0.005
        cylinders      0.503
        displacement   0.688
        horsepower     0.868
        weight         0.000
        acceleration   0.510
        model_year     0.000
        dtype: float64
        &#34;&#34;&#34;
        r2dict = {}
        r2scores = {}
        test_amount = test_size
        for x in range(0, test_amount):
            np.random.seed(seed)
            choices = [.3, .2, .1, .05]
            c = np.random.choice(choices)
            # X = self.drop(target, axis=1).copy()
            # y = self[target].copy()
            df_train, df_test = train_test_split(
                                    self,
                                    test_size=c,
                                    random_state=seed)
            df_train = MLFrame(df_train)
            df_test = MLFrame(df_test)

            model = df_train.lrmodel(target, verbose=False)
            r2dict.update({model.rsquared:(
                model, df_train[target], c)})
            y_train = model.predict(df_train)
            y_test = model.predict(df_test)
            r2_train = r2_score(df_train[target],y_train)
            r2_test = r2_score(df_test[target],y_test)
        model, X, test_size = sorted(r2dict.items(),
                                  key=lambda x: x[0])[-1][1]
        
        self.model = model
        fig, axes = plt.subplots(nrows=2, figsize=(10, 10))
        fig.tight_layout(pad=8.0)
        self.qq_plot(ax=axes[0])
        axes[1].scatter(X, self.model.resid)
        axes[1].axhline(0, color=&#39;k&#39;)
        axes[1].set_xlabel(target)
        axes[1].set_ylabel(&#39;Model Residuals&#39;)
        if verbose:
            print(&#39;test_size = &#39;, test_size)
            try:
                display(model.summary())
            except NameError:
                print(model.summary())
            plt.show()
        return model</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pandas.core.frame.DataFrame</li>
<li>pandas.core.generic.NDFrame</li>
<li>pandas.core.base.PandasObject</li>
<li>pandas.core.accessor.DirNamesMixin</li>
<li>pandas.core.base.SelectionMixin</li>
<li>pandas.core.indexing.IndexingMixin</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="mlframe.mlframe.MLFrame.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="mlframe.mlframe.MLFrame.replace_all"><code class="name flex">
<span>def <span class="ident">replace_all</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces bad characters in a string for
column names to work in a R~formula</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def replace_all(string):
    &#34;&#34;&#34;Replaces bad characters in a string for
    column names to work in a R~formula&#34;&#34;&#34;
    return string.replace(
                  &#39; &#39;, &#39;_&#39;).replace(
                  &#39;(&#39;, &#39;&#39;).replace(
                  &#39;)&#39;, &#39;&#39;).replace(
                #   &#39;1&#39;, &#39;one&#39;).replace(
                #   &#39;2&#39;, &#39;two&#39;).replace(
                #   &#39;3&#39;, &#39;three&#39;).replace(
                #   &#39;4&#39;, &#39;four&#39;).replace(
                #   &#39;5&#39;, &#39;five&#39;).replace(
                #   &#39;6&#39;, &#39;six&#39;).replace(
                #   &#39;7&#39;, &#39;seven&#39;).replace(
                #   &#39;8&#39;, &#39;eight&#39;).replace(
                #   &#39;9&#39;, &#39;nine&#39;).replace(
                  &#39;.&#39;, &#39;_&#39;).replace(
                  &#39;-&#39;, &#39;_&#39;).replace(
                  &#39;/&#39;, &#39;_&#39;).replace(
                  &#39;@&#39;, &#39;_&#39;).replace(
                  &#39;+&#39;, &#39;_&#39;).replace(
                  &#39; &#39;, &#39;_&#39;).replace(
                  &#39; &#39;, &#39;_&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="mlframe.mlframe.MLFrame.columns"><code class="name">var <span class="ident">columns</span> :pandas.core.indexes.base.Index</code></dt>
<dd>
<div class="desc"><p>The column labels of the DataFrame.</p></div>
</dd>
<dt id="mlframe.mlframe.MLFrame.index"><code class="name">var <span class="ident">index</span> :pandas.core.indexes.base.Index</code></dt>
<dd>
<div class="desc"><p>The index (row labels) of the DataFrame.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="mlframe.mlframe.MLFrame.boxplot"><code class="name flex">
<span>def <span class="ident">boxplot</span></span>(<span>self, target, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a seaborn boxplot of target
Parameters</p>
<hr>
<p>target[str]::
Name of the column of which to plot
kwargs{dict}::
Arguments to send in with sns.boxplot()
see:
<a href="https://seaborn.pydata.org/generated/seaborn.boxplot.html">https://seaborn.pydata.org/generated/seaborn.boxplot.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an sns.boxplot</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; df.boxplot('mpg', ax=ax)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boxplot(self, target, **kwargs):
    &#34;&#34;&#34;Plots a seaborn boxplot of target
    Parameters
    ----------------------------------------
    target[str]::
        Name of the column of which to plot
    kwargs{dict}::
        Arguments to send in with sns.boxplot()
        see:
    https://seaborn.pydata.org/generated/seaborn.boxplot.html
    
    Returns
    ----------------------------------------
    an sns.boxplot

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; fig, ax = plt.subplots()
    &gt;&gt;&gt; df.boxplot(&#39;mpg&#39;, ax=ax)
    &#34;&#34;&#34;
    return sns.boxplot(y=self[target], **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.cat_cols"><code class="name flex">
<span>def <span class="ident">cat_cols</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns Categorical columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat_cols(self):
    &#34;&#34;&#34;Computes and returns Categorical columns&#34;&#34;&#34;
    return list(self.select_dtypes(&#39;object&#39;).columns)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.clean_col_names"><code class="name flex">
<span>def <span class="ident">clean_col_names</span></span>(<span>self, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the column names of a DataFrame
for use in an R~Formula</p>
<h2 id="parameters">Parameters</h2>
<p>inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether to show the difference between
the old columns and clean columns or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns a copy</code> of <code>the dataframe</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names()
Columns changed:
model year --&gt; model_year
car name --&gt; car_name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_col_names(self,
                    inplace=False,
                    verbose=True):
    &#34;&#34;&#34;Cleans the column names of a DataFrame
    for use in an R~Formula

    Parameters
    ----------------------------------------
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether to show the difference between
        the old columns and clean columns or not

    Returns
    ----------------------------------------
    None if inplace, otherwise returns a copy of the dataframe

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names()
    Columns changed:
    model year --&gt; model_year
    car name --&gt; car_name
    &#34;&#34;&#34;
    def show_difference(old_cols, new_cols):
        diff = dict(zip(old_cols, new_cols))
        print(&#39;\nColumns changed:&#39;)
        for col in diff.items():
            if col[0] != col[1]:
                print(col[0], &#34;--&gt;&#34;, col[1])

    if inplace:
        new_columns = [self.replace_all(c.strip())
                        for c in self.columns.values.tolist()]
        old_columns = self.columns
        if verbose:
            show_difference(old_columns, new_columns)
        self.columns = new_columns
    else:
        df = self.copy()
        new_columns = [self.replace_all(c.strip())
                        for c in df.columns.values.tolist()]
        old_columns = df.columns
        if verbose:
            show_difference(old_columns, new_columns)
        df.columns = new_columns
        return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@wrapper
def copy(self, *args, **kwargs):
    return super(MLFrame, self).copy(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.distplot"><code class="name flex">
<span>def <span class="ident">distplot</span></span>(<span>self, target, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a seaborn displot of target
Parameters</p>
<hr>
<p>target[str]::
Name of the column of which to plot
kwargs{dict}::
Arguments to send in with sns.distplot()
see:
<a href="https://seaborn.pydata.org/generated/seaborn.distplot.html">https://seaborn.pydata.org/generated/seaborn.distplot.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an sns.distplot</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; df.distplot('mpg', ax=ax)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distplot(self, target, **kwargs):
    &#34;&#34;&#34;Plots a seaborn displot of target
    Parameters
    ----------------------------------------
    target[str]::
        Name of the column of which to plot
    kwargs{dict}::
        Arguments to send in with sns.distplot()
        see:
    https://seaborn.pydata.org/generated/seaborn.distplot.html
        
    
    Returns
    ----------------------------------------
    an sns.distplot

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; fig, ax = plt.subplots()
    &gt;&gt;&gt; df.distplot(&#39;mpg&#39;, ax=ax)
    &#34;&#34;&#34;
    return sns.distplot(self[target], **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.drop"><code class="name flex">
<span>def <span class="ident">drop</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@wrapper
def drop(self, *args, **kwargs):
    return super(MLFrame, self).drop(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.drop_nulls_perc"><code class="name flex">
<span>def <span class="ident">drop_nulls_perc</span></span>(<span>self, perc, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Drops a column if the null value is over a
certain percentage (0-1)</p>
<h2 id="parameters">Parameters</h2>
<p>perc::[float]
The percentage under which nulls are for a column
to get dropped
inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether to print out the series or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns copy</code> of <code>dataframe</code></dt>
<dd>&nbsp;</dd>
<dt><code>with columns dropped</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
...                   columns=['A', 'B', 'C', 'D']))
&gt;&gt;&gt; df['A'].loc[1:3] = np.nan
&gt;&gt;&gt; df['B'].loc[0] = np.nan
&gt;&gt;&gt; df
    A    B   C   D
0  0.0  NaN   2   3
1  NaN  5.0   6   7
2  NaN  9.0  10  11
&gt;&gt;&gt; df.drop_nulls_perc(.4)
    B   C   D
0  NaN   2   3
1  5.0   6   7
2  9.0  10  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_nulls_perc(self, perc,
                    inplace=False,
                    verbose=True):
    &#34;&#34;&#34;Drops a column if the null value is over a
    certain percentage (0-1)

    Parameters
    ----------------------------------------
    perc::[float]
        The percentage under which nulls are for a column
        to get dropped
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether to print out the series or not

    Returns
    ----------------------------------------
    None if inplace, otherwise returns copy of dataframe
    with columns dropped

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
    &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
    &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
    &gt;&gt;&gt; df
        A    B   C   D
    0  0.0  NaN   2   3
    1  NaN  5.0   6   7
    2  NaN  9.0  10  11
    &gt;&gt;&gt; df.drop_nulls_perc(.4)
        B   C   D
    0  NaN   2   3
    1  5.0   6   7
    2  9.0  10  11
    &#34;&#34;&#34;
    nulls = self.isna().sum()
    drop_cols = nulls[nulls/len(self) &gt; perc].index
    if verbose:
        print(&#39;Dropping: &#39;)
        for col in drop_cols:
            print(&#39;    --&gt; &#39;, col)
    return self.drop(columns=drop_cols, inplace=inplace)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.fill_na_mean"><code class="name flex">
<span>def <span class="ident">fill_na_mean</span></span>(<span>self, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills na cells with the mean of it's
respective column</p>
<h2 id="parameters">Parameters</h2>
<p>inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe.
verbose[bool]::
Whether to print out the filling information
or not.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns copy</code> of <code>dataframe</code></dt>
<dd>&nbsp;</dd>
<dt><code>with nulls filled with mean</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
...                   columns=['A', 'B', 'C', 'D']))
&gt;&gt;&gt; df['A'].loc[1:3] = np.nan
&gt;&gt;&gt; df['B'].loc[0] = np.nan
&gt;&gt;&gt; df
    A    B   C   D
0  0.0  NaN   2   3
1  NaN  5.0   6   7
2  NaN  9.0  10  11
&gt;&gt;&gt; df.fill_na_mean()
Filling 66.67% of A with nan
Filling 33.33% of B with 9.0
    A    B    C   D
0  0.0  7.0   2   3
1  0.0  5.0   6   7
2  0.0  9.0  10  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_na_mean(self, inplace=False, verbose=True):
    &#34;&#34;&#34;Fills na cells with the mean of it&#39;s
    respective column

    Parameters
    ----------------------------------------
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe.
    verbose[bool]::
        Whether to print out the filling information
        or not.

    Returns
    ----------------------------------------
    None if inplace, otherwise returns copy of dataframe
    with nulls filled with mean

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
    &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
    &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
    &gt;&gt;&gt; df
        A    B   C   D
    0  0.0  NaN   2   3
    1  NaN  5.0   6   7
    2  NaN  9.0  10  11
    &gt;&gt;&gt; df.fill_na_mean()
    Filling 66.67% of A with nan
    Filling 33.33% of B with 9.0
        A    B    C   D
    0  0.0  7.0   2   3
    1  0.0  5.0   6   7
    2  0.0  9.0  10  11

    &#34;&#34;&#34;
    nulls = self.isna().sum()
    null_perc = nulls[nulls&gt;0]/len(self)
    null_cols = list(null_perc.index)
    null_means = dict(self[null_cols].mean())
    if verbose:
        for col, perc in null_perc.items():
            print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                  &#34;\b%&#34;, &#34;of %s with %s&#34;
                % (col, null_means[col]))
    if inplace:
        for col, mean in null_means.items():
            self[col] = self[col].fillna(mean)
    else:
        df = self.copy()
        for col, mean in null_means.items():
            df[col] = df[col].fillna(mean)
        return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.fill_na_mode"><code class="name flex">
<span>def <span class="ident">fill_na_mode</span></span>(<span>self, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills na cells with the mode of it's
respective column</p>
<h2 id="parameters">Parameters</h2>
<p>inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe.
verbose[bool]::
Whether to print out the filling information
or not.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns copy</code> of <code>dataframe</code></dt>
<dd>&nbsp;</dd>
<dt><code>with nulls filled with mode</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
...                   columns=['A', 'B', 'C', 'D']))
&gt;&gt;&gt; df['A'].loc[1:3] = np.nan
&gt;&gt;&gt; df['B'].loc[0] = np.nan
&gt;&gt;&gt; df
    A    B   C   D
0  0.0  NaN   2   3
1  NaN  5.0   6   7
2  NaN  9.0  10  11
&gt;&gt;&gt; df.fill_na_mode()
Filling 66.67% of A with nan
Filling 33.33% of B with 9.0
    A    B    C   D
0  0.0  5.0   2   3
1  0.0  5.0   6   7
2  0.0  9.0  10  11
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_na_mode(self, inplace=False, verbose=True):
    &#34;&#34;&#34;Fills na cells with the mode of it&#39;s
    respective column

    Parameters
    ----------------------------------------
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe.
    verbose[bool]::
        Whether to print out the filling information
        or not.

    Returns
    ----------------------------------------
    None if inplace, otherwise returns copy of dataframe
    with nulls filled with mode

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
    &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
    &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
    &gt;&gt;&gt; df
        A    B   C   D
    0  0.0  NaN   2   3
    1  NaN  5.0   6   7
    2  NaN  9.0  10  11
    &gt;&gt;&gt; df.fill_na_mode()
    Filling 66.67% of A with nan
    Filling 33.33% of B with 9.0
        A    B    C   D
    0  0.0  5.0   2   3
    1  0.0  5.0   6   7
    2  0.0  9.0  10  11

    &#34;&#34;&#34;
    nulls = self.isna().sum()
    null_perc = nulls[nulls&gt;0]/len(self)
    null_cols = list(null_perc.index)
    null_modes = dict(self[null_cols].mode())
    if verbose:
        for col, perc in null_perc.items():
            print(&#34;Filling %s&#34; % (round(perc*100, 2)),
                  &#34;\b%&#34;, &#34;of %s with %s&#34;
                % (col, null_modes[col]))
    if inplace:
        for col, mode in null_modes.items():
            self[col] = self[col].fillna(mode[0])
    else:
        df = self.copy()
        for col, mode in null_modes.items():
            df[col] = df[col].fillna(mode[0])
        return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.fill_na_perc"><code class="name flex">
<span>def <span class="ident">fill_na_perc</span></span>(<span>self, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><ul>
<li>Not implemented *
Fills na cells with the percent value_counts
of it's respective column</li>
</ul>
<h2 id="parameters">Parameters</h2>
<p>inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether to print out how many were filled
in each column or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns copy</code> of <code>dataframe</code></dt>
<dd>&nbsp;</dd>
<dt><code>with nulls filled with mode</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_na_perc(self, inplace=False, verbose=True):
    &#34;&#34;&#34;
    * Not implemented *
    Fills na cells with the percent value_counts
    of it&#39;s respective column

    Parameters
    ----------------------------------------
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether to print out how many were filled
        in each column or not

    Returns
    ----------------------------------------
    None if inplace, otherwise returns copy of dataframe
    with nulls filled with mode

    Example Usage
    ----------------------------------------
    &#34;&#34;&#34;
    raise AttributeError(&#39;Not Implemented&#39;)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.find_outliers_IQR"><code class="name flex">
<span>def <span class="ident">find_outliers_IQR</span></span>(<span>self, col, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds outliers using the IQR method</p>
<h2 id="parameters">Parameters</h2>
<p>col[str]::
Name of the column to search for outliers in
verbose[bool]::
Whether to print out the series or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True/False Series</code> of <code>the outliers (True is outlier)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; idx_outliers = df.find_outliers_IQR('horsepower', verbose=True)
Found 10 outliers using IQR in horsepower or ~ 2.55%
&gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_outliers_IQR(self, col, verbose=True):
    &#34;&#34;&#34;Finds outliers using the IQR method

    Parameters
    ----------------------------------------
    col[str]::
        Name of the column to search for outliers in
    verbose[bool]::
        Whether to print out the series or not

    Returns
    ----------------------------------------
    True/False Series of the outliers (True is outlier)

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; idx_outliers = df.find_outliers_IQR(&#39;horsepower&#39;, verbose=True)
    Found 10 outliers using IQR in horsepower or ~ 2.55%
    &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
    &#34;&#34;&#34;
    data = self[col]
    res = data.describe()
    IQR = res[&#39;75%&#39;]-res[&#39;25%&#39;]
    thresh = 1.5* IQR
    idx_outliers = ((data&lt;res[&#39;25%&#39;]-thresh)
                     | (data &gt; res[&#39;75%&#39;]+thresh))
    if verbose:
        total = idx_outliers.sum()
        total_perc = round((total/len(self))*100, 2)
        print(&#34;Found {} outliers using IQR in {} or ~ {}%&#34;
              .format(total, col, total_perc))
    return idx_outliers</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.find_outliers_Z"><code class="name flex">
<span>def <span class="ident">find_outliers_Z</span></span>(<span>self, col, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="finds-outliers-using-the-z_score-method">Finds Outliers Using The Z_Score Method</h2>
<p>col[str]::
Name of the column to search for outliers in
verbose[bool]::
Whether to print out the series or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True/False Series</code> of <code>the outliers (True is outlier)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; idx_outliers = df.find_outliers_Z('horsepower', verbose=True)
Found 5 outliers using z_score in horsepower or ~ 1.28%
&gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_outliers_Z(self, col, verbose=True):
    &#34;&#34;&#34;Finds outliers using the z_score method
    ----------------------------------------
    col[str]::
        Name of the column to search for outliers in
    verbose[bool]::
        Whether to print out the series or not

    Returns
    ----------------------------------------
    True/False Series of the outliers (True is outlier)

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; idx_outliers = df.find_outliers_Z(&#39;horsepower&#39;, verbose=True)
    Found 5 outliers using z_score in horsepower or ~ 1.28%
    &gt;&gt;&gt; df = MLFrame(df[~idx_outliers])
    &#34;&#34;&#34;
    data = self[col]
    z_scores = np.abs(stats.zscore(data))
    z_scores = pd.Series(z_scores, index=data.index)
    idx_outliers =z_scores &gt; 3
    if verbose:
        total = idx_outliers.sum()
        total_perc = round((total/len(self))*100, 2)
        print(&#34;Found {} outliers using z_score in {} or ~ {}%&#34;
              .format(total, col, total_perc))
    return idx_outliers    </code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.get_nulls"><code class="name flex">
<span>def <span class="ident">get_nulls</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns sum of all nulls in the dataframe</p>
<h2 id="parameters">Parameters</h2>
<p>verbose[bool]::
Whether to print out the null count of
each row or not</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
...                   columns=['A', 'B', 'C', 'D']))
&gt;&gt;&gt; df['A'].loc[1:3] = np.nan
&gt;&gt;&gt; df['B'].loc[0] = np.nan
&gt;&gt;&gt; df
    A    B   C   D
0  0.0  NaN   2   3
1  NaN  5.0   6   7
2  NaN  9.0  10  11
&gt;&gt;&gt; df.get_nulls(verbose=False)
3
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nulls(self, verbose=True):
    &#34;&#34;&#34;Returns sum of all nulls in the dataframe

    Parameters
    ----------------------------------------
    verbose[bool]::
        Whether to print out the null count of
        each row or not

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.DataFrame(np.arange(12).reshape(3, 4),
    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]))
    &gt;&gt;&gt; df[&#39;A&#39;].loc[1:3] = np.nan
    &gt;&gt;&gt; df[&#39;B&#39;].loc[0] = np.nan
    &gt;&gt;&gt; df
        A    B   C   D
    0  0.0  NaN   2   3
    1  NaN  5.0   6   7
    2  NaN  9.0  10  11
    &gt;&gt;&gt; df.get_nulls(verbose=False)
    3
    &#34;&#34;&#34;
    nulls = self.isna().sum()
    if verbose:
        print(nulls.sort_values(ascending=True))
    nulls = nulls.sum()
    return nulls</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.get_r_squareds"><code class="name flex">
<span>def <span class="ident">get_r_squareds</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests models price to each column in the dataframe.</p>
<h2 id="parameters">Parameters</h2>
<p>verbose[bool]::
Whether to print out the series or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sorted pd.Series</code> of <code>columns --&gt; r_squared</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_r_squareds(self, verbose=True):
    &#34;&#34;&#34;
    Tests models price to each column in the dataframe.

    Parameters
    ----------------------------------------
    verbose[bool]::
        Whether to print out the series or not
    
    Returns
    ----------------------------------------
    sorted pd.Series of columns --&gt; r_squared&#34;&#34;&#34;
    r_squared = {}
    for col in self.columns:
        model = self.lrmodel(&#39;price&#39;, [col], verbose=False)
        r_squared[col] =  model.rsquared
    rs = pd.Series(r_squared).sort_values()
    if verbose:
        print(&#34;R Squareds&#34;)
        print(rs)
    return rs</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.get_vif"><code class="name flex">
<span>def <span class="ident">get_vif</span></span>(<span>self, target, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the Variance Inflation Factor
for the columns of a dataframe based
on the target column</p>
<h2 id="parameters">Parameters</h2>
<p>target[str]::
The column name to base the VIF on
verbose[bool]::
Whether or not to print out the VIF series</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Series</code> of <code>variance_inflation_factor for each column</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.drop(['car name'], axis=1, inplace=True)
&gt;&gt;&gt; df.get_vif('mpg', verbose=False)
const          763.558
cylinders       10.738
displacement    21.837
horsepower       9.944
weight          10.831
acceleration     2.626
model year       1.245
origin           1.772
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vif(self, target, verbose=True):
    &#34;&#34;&#34;Computes the Variance Inflation Factor
    for the columns of a dataframe based
    on the target column

    Parameters
    ----------------------------------------
    target[str]::
        The column name to base the VIF on
    verbose[bool]::
        Whether or not to print out the VIF series

    Returns
    ----------------------------------------
    Series of variance_inflation_factor for each column

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
    &gt;&gt;&gt; df.get_vif(&#39;mpg&#39;, verbose=False)
    const          763.558
    cylinders       10.738
    displacement    21.837
    horsepower       9.944
    weight          10.831
    acceleration     2.626
    model year       1.245
    origin           1.772
    &#34;&#34;&#34;
    X = self.drop(target, axis=1)
    X = sm.add_constant(X)
    vif = [variance_inflation_factor(X.values, i)
        for i in range(X.shape[1])]
    s = pd.Series(dict(zip(X.columns, vif)))
    if verbose:
        print(s)
    return s</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.get_vif_cols"><code class="name flex">
<span>def <span class="ident">get_vif_cols</span></span>(<span>self, target, threshold=6, verbose=True, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes Variance Inflation Factor
for the dataframe, and gets the columns
that are above the defined threshold</p>
<h2 id="parameters">Parameters</h2>
<p>target[str]::
The column name to base the VIF on
threshold=6[int]::
The threshold that columns would be above
where they are an issue, and need to be
looked at
verbose[bool]::
Whether to print out the series or not
inplace[bool]::
Whether to return the series or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Depending on inplace</code></dt>
<dd>&nbsp;</dd>
<dt><code>Series</code> of <code>variance_inflation_factor for each column</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.drop(['car name'], axis=1, inplace=True)
&gt;&gt;&gt; df.get_vif_cols('mpg', verbose=False)
horsepower      9.944
cylinders      10.738
weight         10.831
displacement   21.837
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vif_cols(self, target, threshold=6, verbose=True,
                 inplace=False):
    &#34;&#34;&#34; Computes Variance Inflation Factor
    for the dataframe, and gets the columns
    that are above the defined threshold

    Parameters
    ----------------------------------------
    target[str]::
        The column name to base the VIF on
    threshold=6[int]::
        The threshold that columns would be above
        where they are an issue, and need to be
        looked at
    verbose[bool]::
        Whether to print out the series or not
    inplace[bool]::
        Whether to return the series or not

    Returns
    ----------------------------------------
    Depending on inplace
    Series of variance_inflation_factor for each column

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace=True)
    &gt;&gt;&gt; df.get_vif_cols(&#39;mpg&#39;, verbose=False)
    horsepower      9.944
    cylinders      10.738
    weight         10.831
    displacement   21.837
    dtype: float64
    &#34;&#34;&#34;
    vif_results = self.get_vif(target, verbose=False)
    bad_vif = list(vif_results[vif_results&gt;threshold].index)
    if &#39;const&#39; in bad_vif:
        bad_vif.remove(&#39;const&#39;)
    num_vif = {}
    for col in bad_vif:
        num_vif[col] = vif_results[col]
    s = pd.Series(num_vif).sort_values()
    if verbose:
        print(&#39;\nVIF columns &gt; %s: \n%s&#39;
              % (threshold, s))
    if not inplace:
        return s</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a concise summary of a DataFrame.</p>
<p>This method prints information about a DataFrame including
the index dtype and columns, non-null values and memory usage.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>DataFrame to print information about.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to print the full summary. By default, the setting in
<code>pandas.options.display.max_info_columns</code> is followed.</dd>
<dt><strong><code>buf</code></strong> :&ensp;<code>writable buffer, defaults to sys.stdout</code></dt>
<dd>Where to send the output. By default, the output is printed to
sys.stdout. Pass a writable buffer if you need to further process
the output.</dd>
<dt><strong><code>max_cols</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>When to switch from the verbose to the truncated output. If the
DataFrame has more than <code>max_cols</code> columns, the truncated output
is used. By default, the setting in
<code>pandas.options.display.max_info_columns</code> is used.</dd>
<dt><strong><code>memory_usage</code></strong> :&ensp;<code>bool, str</code>, optional</dt>
<dd>
<p>Specifies whether total memory usage of the DataFrame
elements (including the index) should be displayed. By default,
this follows the <code>pandas.options.display.memory_usage</code> setting.</p>
<p>True always show memory usage. False never shows memory usage.
A value of 'deep' is equivalent to "True with deep introspection".
Memory usage is shown in human-readable units (base-2
representation). Without deep introspection a memory estimation is
made based in column dtype and number of rows assuming values
consume the same memory amount for corresponding dtypes. With deep
memory introspection, a real memory usage calculation is performed
at the cost of computational resources.</p>
</dd>
<dt><strong><code>null_counts</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the non-null counts. By default, this is shown
only if the DataFrame is smaller than
<code>pandas.options.display.max_info_rows</code> and
<code>pandas.options.display.max_info_columns</code>. A value of True always
shows the counts, and False never shows the counts.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>This method prints a summary of a DataFrame and returns None.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>DataFrame.describe: Generate descriptive statistics of DataFrame columns. DataFrame.memory_usage: Memory usage of DataFrame columns.</code></p>
<h2 id="examples">Examples</h2>
<pre><code>        &gt;&gt;&gt; int_values = [1, 2, 3, 4, 5]
        &gt;&gt;&gt; text_values = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']
        &gt;&gt;&gt; float_values = [0.0, 0.25, 0.5, 0.75, 1.0]
        &gt;&gt;&gt; df = pd.DataFrame({"int_col": int_values, "text_col": text_values,
        ...                   "float_col": float_values})
        &gt;&gt;&gt; df
            int_col text_col  float_col
        0        1    alpha       0.00
        1        2     beta       0.25
        2        3    gamma       0.50
        3        4    delta       0.75
        4        5  epsilon       1.00

        Prints information of all columns:

        &gt;&gt;&gt; df.info(verbose=True)
        &lt;class 'pandas.core.frame.DataFrame'&gt;
        RangeIndex: 5 entries, 0 to 4
        Data columns (total 3 columns):
         #   Column     Non-Null Count  Dtype
        ---  ------     --------------  -----
         0   int_col    5 non-null      int64
         1   text_col   5 non-null      object
         2   float_col  5 non-null      float64
        dtypes: float64(1), int64(1), object(1)
        memory usage: 248.0+ bytes

        Prints a summary of columns count and its dtypes but not per column
        information:

        &gt;&gt;&gt; df.info(verbose=False)
        &lt;class 'pandas.core.frame.DataFrame'&gt;
        RangeIndex: 5 entries, 0 to 4
        Columns: 3 entries, int_col to float_col
        dtypes: float64(1), int64(1), object(1)
        memory usage: 248.0+ bytes

        Pipe output of DataFrame.info to buffer instead of sys.stdout, get
        buffer content and writes to a text file:

        &gt;&gt;&gt; import io
        &gt;&gt;&gt; buffer = io.StringIO()
        &gt;&gt;&gt; df.info(buf=buffer)
        &gt;&gt;&gt; s = buffer.getvalue()
        &gt;&gt;&gt; with open("df_info.txt", "w",
        ...           encoding="utf-8") as f:  # doctest: +SKIP
        ...     f.write(s)
        260

        The &lt;code&gt;memory\_usage&lt;/code&gt; parameter allows deep introspection mode, specially
        useful for big DataFrames and fine-tune memory optimization:

        &gt;&gt;&gt; random_strings_array = np.random.choice(['a', 'b', 'c'], 10 ** 6)
        &gt;&gt;&gt; df = pd.DataFrame({
        ...     'column_1': np.random.choice(['a', 'b', 'c'], 10 ** 6),
        ...     'column_2': np.random.choice(['a', 'b', 'c'], 10 ** 6),
        ...     'column_3': np.random.choice(['a', 'b', 'c'], 10 ** 6)
        ... })
        &gt;&gt;&gt; df.info()
        &lt;class 'pandas.core.frame.DataFrame'&gt;
        RangeIndex: 1000000 entries, 0 to 999999
        Data columns (total 3 columns):
         #   Column    Non-Null Count    Dtype
        ---  ------    --------------    -----
         0   column_1  1000000 non-null  object
         1   column_2  1000000 non-null  object
         2   column_3  1000000 non-null  object
        dtypes: object(3)
        memory usage: 22.9+ MB

        &gt;&gt;&gt; df.info(memory_usage='deep')
        &lt;class 'pandas.core.frame.DataFrame'&gt;
        RangeIndex: 1000000 entries, 0 to 999999
        Data columns (total 3 columns):
         #   Column    Non-Null Count    Dtype
        ---  ------    --------------    -----
         0   column_1  1000000 non-null  object
         1   column_2  1000000 non-null  object
         2   column_3  1000000 non-null  object
        dtypes: object(3)
        memory usage: 188.8 MB
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self, *args, **kwargs):
    print(&#34;Model is %s\n&#34; % self.model)
    return super(MLFrame, self).info(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.jointplot"><code class="name flex">
<span>def <span class="ident">jointplot</span></span>(<span>self, x, target, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a seaborn jointplot of x and target
Parameters</p>
<hr>
<p>x[str]::
Name of a column to plot x
target[str]::
Name of the column of which to target
kwargs{dict}::
Arguments to send in with sns.jointplot()
see:
<a href="https://seaborn.pydata.org/generated/seaborn.jointplot.html">https://seaborn.pydata.org/generated/seaborn.jointplot.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an sns.jointplot</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.jointplot('horsepower', 'mpg')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jointplot(self, x, target, **kwargs):
    &#34;&#34;&#34;Plots a seaborn jointplot of x and target
    Parameters
    ----------------------------------------
    x[str]::
        Name of a column to plot x
    target[str]::
        Name of the column of which to target
    kwargs{dict}::
        Arguments to send in with sns.jointplot()
        see:
    https://seaborn.pydata.org/generated/seaborn.jointplot.html
    
    Returns
    ----------------------------------------
    an sns.jointplot

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.jointplot(&#39;horsepower&#39;, &#39;mpg&#39;)
    &#34;&#34;&#34;
    return sns.jointplot(data=self, x=x, y=target, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, columns, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>logs the listed columns of the dataframe
Parameters</p>
<hr>
<p>columns[list, str]::
A list of columns to make logarithmic
inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether to print out logged columns or not</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace otherwise returns a copy</code></dt>
<dd>&nbsp;</dd>
<dt><code>of the dataframe with columns logged</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.drop(['car name'], axis=1, inplace = True)
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; df = df.log(columns=['mpg', 'cylinders'])
</code></pre>
<h2 id="logging">Logging</h2>
<p>mpg
cylinders</p>
<h1 id="or">OR</h1>
<pre><code class="python-repl">&gt;&gt;&gt; df.log('mpg', inplace=True)
</code></pre>
<h2 id="logging_1">Logging</h2>
<p>mpg</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, columns, inplace=False, verbose=True):
    &#34;&#34;&#34; logs the listed columns of the dataframe
    Parameters
    ----------------------------------------
    columns[list, str]::
        A list of columns to make logarithmic
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether to print out logged columns or not

    Returns
    ----------------------------------------
    None if inplace otherwise returns a copy
    of the dataframe with columns logged

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
    
    &gt;&gt;&gt; df = df.log(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
    Logging:
       mpg
       cylinders
    # OR
    &gt;&gt;&gt; df.log(&#39;mpg&#39;, inplace=True)
    Logging:
       mpg
    &#34;&#34;&#34;
    if verbose:
        print(&#34;\nLogging:&#34;)
        if isinstance(columns, list):
            for col in columns:
                print(&#34;  &#34;, col)
        else:
            print(&#34;  &#34;, columns)
    if inplace:
        if isinstance(columns, list):
            for col in columns:
                self[col] = np.log(self[col])
        else:
            self[columns] = np.log(self[columns])
    else:
        df = self.copy()
        if isinstance(columns, list):
            for col in columns:
                df[col] = np.log(df[col])
        else:
            df[columns] = np.log(df[columns])
        return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.lrmodel"><code class="name flex">
<span>def <span class="ident">lrmodel</span></span>(<span>self, target=None, columns=[], inplace=False, verbose=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a LinearRegression model of target</p>
<h2 id="parameters">Parameters</h2>
<p>target::[str]
The target for which to model on
cols[list]::
a list of columns of which to build the model
on.
If empty, uses all columns-target
inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether or not to display the model.summary()
kwargs{dict}::
Arguments that are sent to Model.from_formula()
see:
<a href="https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html">https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None if inplace, otherwise returns the model</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True)
&gt;&gt;&gt; df.lrmodel('mpg', verbose=False, inplace=True)
&gt;&gt;&gt; df.model.pvalues.max()
0.9996627853521083
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lrmodel(self,
             target=None,
             columns=[],
             inplace=False,
             verbose=True,
             **kwargs):
    &#34;&#34;&#34;Creates a LinearRegression model of target

    Parameters
    ----------------------------------------
    target::[str]
        The target for which to model on
    cols[list]::
        a list of columns of which to build the model
        on.  If empty, uses all columns-target
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether or not to display the model.summary()
    kwargs{dict}::
        Arguments that are sent to Model.from_formula()
        see:
    https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

    Returns
    ----------------------------------------
    None if inplace, otherwise returns the model

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True)
    &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, verbose=False, inplace=True)
    &gt;&gt;&gt; df.model.pvalues.max()
    0.9996627853521083
    &#34;&#34;&#34;
    if not target:
        raise AttributeError(&#39;No target defined&#39;)
    if not columns:
        columns = self.drop(target, axis=1).columns
    cols_form = &#39;+&#39;.join(columns)
    # cols_form = cols_form.replace(&#39; &#39;, &#39;&#39;)
    formula=&#39;%s~%s&#39; % (target, cols_form)
    # possibly svd did not converge here
    kwds = dict(formula=formula, data=self)
    kwds.update(**kwargs)
    model = smf.ols(**kwds).fit()
    try:  # undefined if used outside jupyter
        if verbose:
            display(model.summary())
    except NameError:
        print(model.summary())
    
    if inplace:
        self.model = model
    else:
        return model</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.model_and_plot"><code class="name flex">
<span>def <span class="ident">model_and_plot</span></span>(<span>self, target, figsize=(10, 10), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a new model based on target, plots a
scatter plot of (target, model residuals), and
plots a qqplot based on the model residuals.</p>
<h2 id="parameters">Parameters</h2>
<p>target::[str]
The target for which to model on
kwargs{dict}::
Arguments that are sent to Model.from_formula()
see:
<a href="https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html">https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>model</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True)
&gt;&gt;&gt; df.model_and_plot('mpg')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_and_plot(self,
                  target,
                  figsize=(10, 10),
                  **kwargs):
    &#34;&#34;&#34;Creates a new model based on target, plots a
    scatter plot of (target, model residuals), and
    plots a qqplot based on the model residuals.

    Parameters
    ----------------------------------------
    target::[str]
        The target for which to model on
    kwargs{dict}::
        Arguments that are sent to Model.from_formula()
        see:
    https://www.statsmodels.org/stable/generated/statsmodels.formula.api.ols.html

    Returns
    ----------------------------------------
    model

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True)
    &gt;&gt;&gt; df.model_and_plot(&#39;mpg&#39;)
    &#34;&#34;&#34;
    self.lrmodel(target=target, inplace=True, verbose=True, **kwargs)
    model = self.model
    fig, axes = plt.subplots(nrows=2, figsize=figsize)
    fig.tight_layout(pad=8.0)
    self.qq_plot(ax=axes[0])
    self.model_resid_scatter(target, ax=axes[1],
        title=&#39;Model Residual Scatter plot&#39;,
        line_kws=dict(color=&#39;k&#39;))
    return model</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.model_resid_scatter"><code class="name flex">
<span>def <span class="ident">model_resid_scatter</span></span>(<span>self, target, ax=None, title='', scatter_kws={}, line_kws={})</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a scatter plot and axhline
based on target and the model's residuals</p>
<h2 id="parameters">Parameters</h2>
<p>target[str]::
The target of the model
title[str]::
The title of the plot
ax[matplotlib.axes]:
The axis to plot onto
scatter_kws{dict}::
Arguments to send to the scatter plot
see:
<a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.scatter.html">https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.scatter.html</a>
line_kws{dict}::
Arguments to send to the axhline
see:
<a href="https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.axhline.html">https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.axhline.html</a></p>
<h2 id="returns">Returns</h2>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True)
&gt;&gt;&gt; df.lrmodel('mpg', inplace=True)
&gt;&gt;&gt; df.model_resid_scatter('mpg')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_resid_scatter(self, target, ax=None,
                        title=&#39;&#39;,
                        scatter_kws={}, line_kws={}):
    &#34;&#34;&#34;Plots a scatter plot and axhline 
    based on target and the model&#39;s residuals

    Parameters
    ----------------------------------------
    target[str]::
        The target of the model
    title[str]::
        The title of the plot
    ax[matplotlib.axes]:
        The axis to plot onto
    scatter_kws{dict}::
        Arguments to send to the scatter plot
        see:
    https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.scatter.html
    line_kws{dict}::
        Arguments to send to the axhline
        see:
    https://matplotlib.org/3.3.1/api/_as_gen/matplotlib.pyplot.axhline.html

    Returns
    ----------------------------------------
    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True)
    &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
    &gt;&gt;&gt; df.model_resid_scatter(&#39;mpg&#39;)
    &#34;&#34;&#34;
    if ax:
        ax.set_title(title)
        ax.scatter(x=self[target],
                   y=self.model.resid,
                   **scatter_kws)
        ax.axhline(0, **line_kws)
        ax.set_xlabel(target)
        ax.set_ylabel(&#39;Model Residuals&#39;)
    else:
        plt.title(title)
        plt.scatter(self[target],
                    self.model.resid,
                    **scatter_kws)
        plt.axhline(0, **line_kws)
        plt.xlabel(target)
        plt.ylabel(&#39;Model Residuals&#39;)
        plt.show()</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.ms_matrix"><code class="name flex">
<span>def <span class="ident">ms_matrix</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a missingno matrix</p>
<h2 id="parameters">Parameters</h2>
<p>kwargs{dict}::
Arguments to send to ms.matrix</p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.ms_matrix()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ms_matrix(self, **kwargs):
    &#34;&#34;&#34;Plots a missingno matrix

    Parameters
    ----------------------------------------
    kwargs{dict}::
        Arguments to send to ms.matrix
    
    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.ms_matrix()

    &#34;&#34;&#34;
    return ms.matrix(self, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.num_cols"><code class="name flex">
<span>def <span class="ident">num_cols</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes and returns Numerical columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def num_cols(self):
    &#34;&#34;&#34;Computes and returns Numerical columns&#34;&#34;&#34;
    return list(self.select_dtypes(&#39;number&#39;).columns)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.one_hot_encode"><code class="name flex">
<span>def <span class="ident">one_hot_encode</span></span>(<span>self, columns=[], drop_first=True, verbose=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a one hot encoded dataframe</p>
<h2 id="parameters">Parameters</h2>
<p>columns[list]::
list of columns to one hot encode
uses self.cat_cols() if not defined
drop_first=True::
whether to drop the first column or not
to rid of multicollinearity
verbose[bool]::
Whether to print out the series or not
kwargs{dict}::
Arguments to send to pd.get_dummies
see:
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>encoded dataframe</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(verbose=False, inplace=True)
&gt;&gt;&gt; # splitting car_name into model for categorizing
&gt;&gt;&gt; df['model'] = df['car_name'].apply(
&gt;&gt;&gt;     lambda x: x.split(' ')[0])
&gt;&gt;&gt; df_ohe = df.one_hot_encode(columns=['model'])
Added categorical columns
37 -&gt; model
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_hot_encode(self,
                    columns=[],
                    drop_first=True,
                    verbose=True,
                    **kwargs):
    &#34;&#34;&#34;Makes a one hot encoded dataframe

    Parameters
    ----------------------------------------
    columns[list]::
        list of columns to one hot encode
        uses self.cat_cols() if not defined
    drop_first=True::
        whether to drop the first column or not
        to rid of multicollinearity
    verbose[bool]::
        Whether to print out the series or not
    kwargs{dict}::
        Arguments to send to pd.get_dummies
        see:
    https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.get_dummies.html

    Returns
    ----------------------------------------
    encoded dataframe

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(verbose=False, inplace=True)
    &gt;&gt;&gt; # splitting car_name into model for categorizing
    &gt;&gt;&gt; df[&#39;model&#39;] = df[&#39;car_name&#39;].apply(
    &gt;&gt;&gt;     lambda x: x.split(&#39; &#39;)[0])
    &gt;&gt;&gt; df_ohe = df.one_hot_encode(columns=[&#39;model&#39;])
    Added categorical columns
    37 -&gt; model
    &#34;&#34;&#34;
    if not isinstance(columns, list):
        raise(AttributeError(&#39;%s not a list&#39; % columns))
    elif not columns:
        columns = self.cat_cols()
    df = MLFrame(pd.get_dummies(self,
                                columns=columns,
                                drop_first=drop_first,
                                **kwargs))
    
    if verbose:
        print(&#34;Added categorical columns&#34;)
        count_dict = {}
        for col in self.columns:
            count = 0
            for col_ohe in df.columns:
                if col in col_ohe:
                    count += 1
            if count &gt; 1:
                count_dict[col] = count
        for col, num in sorted(count_dict.items(), 
                key=lambda x: x[1]):
            print(num, &#39;-&gt;&#39;, col)
                            
    return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.outlier_removal"><code class="name flex">
<span>def <span class="ident">outlier_removal</span></span>(<span>self, columns=[], IQR=False, z_score=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes outliers based on IQR or z_score</p>
<h2 id="parameters">Parameters</h2>
<p>column[list, str]::
The columns of which to remove outliers
if blank, removes from all columns
IQR[bool]::
Whether or not to remove outliers
using IQR method
z_score[bool]::
Whether or not to remove outliers
using z_score method
verbose[bool]::
Whether to print how many outliers were
found in each column or now
</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Copy</code> of <code>dataframe with outliers removed</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df = df.outlier_removal('horsepower',
...                          IQR=True)
Found 10 outliers using IQR in horsepower or ~ 2.55%
Removed
&gt;&gt;&gt; # OR
&gt;&gt;&gt; df = df.outlier_removal(['horsepower', 'mpg'], 
                         z_score=True)
Found 10 outliers using z_score in horsepower or ~ 2.55%
Removed
Found 0 outliers using z_score in mpg or ~ 0.0%
Removed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def outlier_removal(self,
                    columns=[],
                    IQR=False,
                    z_score=False,
                    verbose=True):
    &#34;&#34;&#34;Removes outliers based on IQR or z_score

    Parameters
    ----------------------------------------
    column[list, str]::
        The columns of which to remove outliers
        if blank, removes from all columns
    IQR[bool]::
        Whether or not to remove outliers
        using IQR method
    z_score[bool]::
        Whether or not to remove outliers
        using z_score method
    verbose[bool]::
        Whether to print how many outliers were
        found in each column or now       

    Returns
    ----------------------------------------
    Copy of dataframe with outliers removed

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df = df.outlier_removal(&#39;horsepower&#39;,
    ...                          IQR=True)
    Found 10 outliers using IQR in horsepower or ~ 2.55%
    Removed
    &gt;&gt;&gt; # OR
    &gt;&gt;&gt; df = df.outlier_removal([&#39;horsepower&#39;, &#39;mpg&#39;], 
                             z_score=True)
    Found 10 outliers using z_score in horsepower or ~ 2.55%
    Removed
    Found 0 outliers using z_score in mpg or ~ 0.0%
    Removed
    &#34;&#34;&#34;
    if IQR:
        func = partial(self.find_outliers_IQR,
                       verbose=verbose)
    elif z_score:
        func = partial(self.find_outliers_Z,
                       verbose=verbose)
    try:
        func
    except UnboundLocalError:
        msg = &#34;No method defined, try z_score=True, or IQR=True&#34;
        raise AttributeError(msg)
    df = self.copy()
    if isinstance(columns, list):
        if not columns:
            columns = self.columns
        for col in columns:
            outliers = func(col)
            num = len(df)
            df = df[~outliers]
            if verbose:
                print(&#39;Removed&#39;)
    else:
        outliers = func(columns)
        df = df[~outliers]
        if verbose:
            print(&#39;Removed&#39;)
    return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.plot_coef"><code class="name flex">
<span>def <span class="ident">plot_coef</span></span>(<span>self, cmap='Greens')</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a predefined plot
of the model's coefficients</p>
<p>cmap[str]:: Default is Greens
The style.background_gradient color
see:
<a href="https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html">https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html</a></p>
<h2 id="returns">Returns</h2>
<p><pandas.io.formats.style.Styler></p>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
&gt;&gt;&gt; df.drop('car_name', axis=1, inplace=True)
&gt;&gt;&gt; df.plot_coef()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_coef(self, cmap=&#39;Greens&#39;):
    &#34;&#34;&#34;Plots a predefined plot
    of the model&#39;s coefficients

    cmap[str]:: Default is Greens
        The style.background_gradient color
        see:
    https://matplotlib.org/3.3.1/tutorials/colors/colormaps.html

    Returns
    ----------------------------------------
    &lt;pandas.io.formats.style.Styler&gt;
    
    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
    &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
    &gt;&gt;&gt; df.plot_coef()
    &#34;&#34;&#34;
    coeffs = self.model.params.sort_values(ascending=False)
    frame = coeffs.to_frame(&#39;Coefficients&#39;)
    styler = frame.style.background_gradient(cmap=cmap)
    return styler</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.plot_corr"><code class="name flex">
<span>def <span class="ident">plot_corr</span></span>(<span>self, figsize=(25, 25), annot=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a predefined correlation heatmap</p>
<h2 id="parameters">Parameters</h2>
<p>figsize(tu, ple)::
The size of the plotted figure
annot[bool]::
Whether or not to annotate the cells
kwargs{dict}::
Arguments that are sent to sns.heatmap
see:
<a href="https://seaborn.pydata.org/generated/seaborn.heatmap.html">https://seaborn.pydata.org/generated/seaborn.heatmap.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fig, ax</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
&gt;&gt;&gt; df.drop('car_name', axis=1, inplace=True)
&gt;&gt;&gt; df.plot_corr(annot=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_corr(self, figsize=(25, 25), annot=False,
              **kwargs):
    &#34;&#34;&#34;Plots a predefined correlation heatmap

    Parameters
    ----------------------------------------
    figsize(tu, ple)::
        The size of the plotted figure
    annot[bool]::
        Whether or not to annotate the cells
    kwargs{dict}::
        Arguments that are sent to sns.heatmap
        see:
    https://seaborn.pydata.org/generated/seaborn.heatmap.html

    Returns
    ----------------------------------------
    fig, ax
    
    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True, verbose=False)
    &gt;&gt;&gt; df.drop(&#39;car_name&#39;, axis=1, inplace=True)
    &gt;&gt;&gt; df.plot_corr(annot=True)
    &#34;&#34;&#34;
    corr=np.abs(self.corr())
    fig, ax = plt.subplots(figsize=figsize)
    mask=np.zeros_like(corr, dtype=np.bool)
    mask[np.triu_indices_from(mask, k=0)] = True
    kwds = dict(mask=mask,
                cmap=sns.diverging_palette(240, 10, n=10),
                annot=annot,
                center=0,
                ax=ax,
                linewidths=1,
                square=True,
                cbar_kws={&#39;shrink&#39;:0.6})
    kwds.update(**kwargs)
    sns.heatmap(corr, **kwds)
    return fig, ax</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.qq_plot"><code class="name flex">
<span>def <span class="ident">qq_plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a statsmodels QQplot of the dataframe</p>
<h2 id="parameters">Parameters</h2>
<p>kwargs{dict}::
Arguments to send to sm.graphics.qqplot()
see:
<a href="https://www.statsmodels.org/stable/generated/statsmodels.graphics.gofplots.qqplot.html">https://www.statsmodels.org/stable/generated/statsmodels.graphics.gofplots.qqplot.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sm.graphics.qqplot()</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True)
&gt;&gt;&gt; df.lrmodel('mpg', inplace=True)
&gt;&gt;&gt; df.qq_plot()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qq_plot(self, **kwargs):
    &#34;&#34;&#34;Plots a statsmodels QQplot of the dataframe

    Parameters
    ----------------------------------------
    kwargs{dict}::
        Arguments to send to sm.graphics.qqplot()
        see:
    https://www.statsmodels.org/stable/generated/statsmodels.graphics.gofplots.qqplot.html

    Returns
    ----------------------------------------
    sm.graphics.qqplot()

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True)
    &gt;&gt;&gt; df.lrmodel(&#39;mpg&#39;, inplace=True)
    &gt;&gt;&gt; df.qq_plot()
    &#34;&#34;&#34;
    if self.model:
        if &#39;ax&#39; in kwargs:
            kwargs[&#39;ax&#39;].set_title(&#39;Model Residual QQ plot&#39;)
        return sm.graphics.qqplot(self.model.resid,
                    fit=True, line=&#39;45&#39;, **kwargs)
    else:
        raise AttributeError(&#39;No model defined&#39;)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.regplot"><code class="name flex">
<span>def <span class="ident">regplot</span></span>(<span>self, x, y, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a seaborn regplot of x and y</p>
<h2 id="parameters">Parameters</h2>
<p>x[str]::
Name of a column to plot x
y[str]::
Name of a column to plot y
kwargs{dict}::
Arguments that are sent to sns.regplot
see:
<a href="https://seaborn.pydata.org/generated/seaborn.regplot.html">https://seaborn.pydata.org/generated/seaborn.regplot.html</a></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>an sns.regplot</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; fig, ax = plt.subplots()
&gt;&gt;&gt; df.regplot('horsepower', 'mpg', ax=ax)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regplot(self, x, y, **kwargs):
    &#34;&#34;&#34;Plots a seaborn regplot of x and y

    Parameters
    ----------------------------------------
    x[str]::
        Name of a column to plot x
    y[str]::
        Name of a column to plot y
    kwargs{dict}::
        Arguments that are sent to sns.regplot
        see:
    https://seaborn.pydata.org/generated/seaborn.regplot.html

    Returns
    ----------------------------------------
    an sns.regplot

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; fig, ax = plt.subplots()
    &gt;&gt;&gt; df.regplot(&#39;horsepower&#39;, &#39;mpg&#39;, ax=ax)
    &#34;&#34;&#34;
    return sns.regplot(x, y, data=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, columns, inplace=False, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Scales the listed columns of the dataframe
Parameters</p>
<hr>
<p>columns[list, str]::
A list of columns to scale
inplace[bool]::
Defines whether to return a new dataframe or
mutate the dataframe
verbose[bool]::
Whether to print out the scaled columns or not</p>
<h2 id="returns">Returns</h2>
<p>None if inplace otherwise returns a copy
of the dataframe with columns scaled
Example Usage</p>
<hr>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.drop(['car name'], axis=1, inplace = True)
</code></pre>
<pre><code class="python-repl">&gt;&gt;&gt; df = df.scale(columns=['mpg', 'cylinders'])
</code></pre>
<h2 id="scaling">Scaling</h2>
<p>mpg
cylinders</p>
<h1 id="or">OR</h1>
<pre><code class="python-repl">&gt;&gt;&gt; df.scale('mpg', inplace=True)
</code></pre>
<h2 id="scaling_1">Scaling</h2>
<p>mpg</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, columns, inplace=False, verbose=True):
    &#34;&#34;&#34; Scales the listed columns of the dataframe
    Parameters
    ----------------------------------------
    columns[list, str]::
        A list of columns to scale
    inplace[bool]::
        Defines whether to return a new dataframe or
        mutate the dataframe
    verbose[bool]::
        Whether to print out the scaled columns or not

    Returns:
        None if inplace otherwise returns a copy
        of the dataframe with columns scaled

    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.drop([&#39;car name&#39;], axis=1, inplace = True)
    
    &gt;&gt;&gt; df = df.scale(columns=[&#39;mpg&#39;, &#39;cylinders&#39;])
    Scaling:
       mpg
       cylinders
    # OR
    &gt;&gt;&gt; df.scale(&#39;mpg&#39;, inplace=True)
    Scaling:
       mpg
    &#34;&#34;&#34;
    def scale(df, col):
        df[col] = ((df[col] - np.mean(df[col]))
                  / np.sqrt(np.var(df[col])))
    if verbose:
        print(&#34;\nScaling:&#34;)
        if isinstance(columns, list):
            for col in columns:
                print(&#34;  &#34;, col)
        else:
            print(&#34;  &#34;, columns)
    if inplace:
        if isinstance(columns, list):
            for col in columns:
                scale(self, col)
        else:
            scale(self, columns)
    else:
        df = self.copy()
        if isinstance(columns, list):
            for col in columns:
                scale(df, col)
        else:
            scale(df, columns)
        return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.train_test_split"><code class="name flex">
<span>def <span class="ident">train_test_split</span></span>(<span>self, target, test_size=100, seed=42, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<p>target[str]::
Name of the column of which to target
test_size[int]::
How many times to run the train_test_split
seed[int]::
The random seed to use
verbose[bool]::
Whether or not to show the model and plots</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>model[sm.regression.linear_model.RegressionResultsWrapper]::</code></dt>
<dd>The best model of the train_test_split</dd>
</dl>
<h2 id="example-usage">Example Usage</h2>
<pre><code class="python-repl">&gt;&gt;&gt; df = MLFrame(pd.read_csv('mltools/tests/auto-mpg.csv'))
&gt;&gt;&gt; df.clean_col_names(inplace=True)
&gt;&gt;&gt; df.drop(['car_name', 'origin'], axis=1, inplace=True)
&gt;&gt;&gt; model = df.train_test_split('mpg',
                                test_size=5,
                                verbose=False)
&gt;&gt;&gt; model.pvalues
Intercept      0.005
cylinders      0.503
displacement   0.688
horsepower     0.868
weight         0.000
acceleration   0.510
model_year     0.000
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train_test_split(self,
                     target,
                     test_size=100,
                     seed=42,
                     verbose=True):
    &#34;&#34;&#34;
    Parameters
    ----------------------------------------
    target[str]::
        Name of the column of which to target
    test_size[int]::
        How many times to run the train_test_split
    seed[int]::
        The random seed to use
    verbose[bool]::
        Whether or not to show the model and plots
    
    Returns
    ----------------------------------------
    model[sm.regression.linear_model.RegressionResultsWrapper]::
        The best model of the train_test_split
    
    Example Usage
    ----------------------------------------
    &gt;&gt;&gt; df = MLFrame(pd.read_csv(&#39;mltools/tests/auto-mpg.csv&#39;))
    &gt;&gt;&gt; df.clean_col_names(inplace=True)
    &gt;&gt;&gt; df.drop([&#39;car_name&#39;, &#39;origin&#39;], axis=1, inplace=True)
    &gt;&gt;&gt; model = df.train_test_split(&#39;mpg&#39;,
                                    test_size=5,
                                    verbose=False)
    &gt;&gt;&gt; model.pvalues
    Intercept      0.005
    cylinders      0.503
    displacement   0.688
    horsepower     0.868
    weight         0.000
    acceleration   0.510
    model_year     0.000
    dtype: float64
    &#34;&#34;&#34;
    r2dict = {}
    r2scores = {}
    test_amount = test_size
    for x in range(0, test_amount):
        np.random.seed(seed)
        choices = [.3, .2, .1, .05]
        c = np.random.choice(choices)
        # X = self.drop(target, axis=1).copy()
        # y = self[target].copy()
        df_train, df_test = train_test_split(
                                self,
                                test_size=c,
                                random_state=seed)
        df_train = MLFrame(df_train)
        df_test = MLFrame(df_test)

        model = df_train.lrmodel(target, verbose=False)
        r2dict.update({model.rsquared:(
            model, df_train[target], c)})
        y_train = model.predict(df_train)
        y_test = model.predict(df_test)
        r2_train = r2_score(df_train[target],y_train)
        r2_test = r2_score(df_test[target],y_test)
    model, X, test_size = sorted(r2dict.items(),
                              key=lambda x: x[0])[-1][1]
    
    self.model = model
    fig, axes = plt.subplots(nrows=2, figsize=(10, 10))
    fig.tight_layout(pad=8.0)
    self.qq_plot(ax=axes[0])
    axes[1].scatter(X, self.model.resid)
    axes[1].axhline(0, color=&#39;k&#39;)
    axes[1].set_xlabel(target)
    axes[1].set_ylabel(&#39;Model Residuals&#39;)
    if verbose:
        print(&#39;test_size = &#39;, test_size)
        try:
            display(model.summary())
        except NameError:
            print(model.summary())
        plt.show()
    return model</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.wrap__getitem__"><code class="name flex">
<span>def <span class="ident">wrap__getitem__</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@wrapper
def wrap__getitem__(self, df):
    return df</code></pre>
</details>
</dd>
<dt id="mlframe.mlframe.MLFrame.wrapper"><code class="name flex">
<span>def <span class="ident">wrapper</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper to return a MLFrame, and set
the model when defined pd.DataFrame methods
are used on a MLFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(func):
    &#34;&#34;&#34;Wrapper to return a MLFrame, and set
    the model when defined pd.DataFrame methods
    are used on a MLFrame&#34;&#34;&#34;
    @wraps(func)
    @inherit_docstrings
    def inner(self, *args, **kwargs):
        frame = func(self, *args, **kwargs)
        frame = MLFrame(frame)
        frame.model = self.model
        return frame
    return inner</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mlframe" href="index.html">mlframe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mlframe.mlframe.inherit_docstrings" href="#mlframe.mlframe.inherit_docstrings">inherit_docstrings</a></code></li>
<li><code><a title="mlframe.mlframe.test_car" href="#mlframe.mlframe.test_car">test_car</a></code></li>
<li><code><a title="mlframe.mlframe.test_houses" href="#mlframe.mlframe.test_houses">test_houses</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mlframe.mlframe.MLFrame" href="#mlframe.mlframe.MLFrame">MLFrame</a></code></h4>
<ul class="two-column">
<li><code><a title="mlframe.mlframe.MLFrame.boxplot" href="#mlframe.mlframe.MLFrame.boxplot">boxplot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.cat_cols" href="#mlframe.mlframe.MLFrame.cat_cols">cat_cols</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.clean_col_names" href="#mlframe.mlframe.MLFrame.clean_col_names">clean_col_names</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.columns" href="#mlframe.mlframe.MLFrame.columns">columns</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.copy" href="#mlframe.mlframe.MLFrame.copy">copy</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.distplot" href="#mlframe.mlframe.MLFrame.distplot">distplot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.drop" href="#mlframe.mlframe.MLFrame.drop">drop</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.drop_nulls_perc" href="#mlframe.mlframe.MLFrame.drop_nulls_perc">drop_nulls_perc</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.fill_na_mean" href="#mlframe.mlframe.MLFrame.fill_na_mean">fill_na_mean</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.fill_na_mode" href="#mlframe.mlframe.MLFrame.fill_na_mode">fill_na_mode</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.fill_na_perc" href="#mlframe.mlframe.MLFrame.fill_na_perc">fill_na_perc</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.find_outliers_IQR" href="#mlframe.mlframe.MLFrame.find_outliers_IQR">find_outliers_IQR</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.find_outliers_Z" href="#mlframe.mlframe.MLFrame.find_outliers_Z">find_outliers_Z</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.get_nulls" href="#mlframe.mlframe.MLFrame.get_nulls">get_nulls</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.get_r_squareds" href="#mlframe.mlframe.MLFrame.get_r_squareds">get_r_squareds</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.get_vif" href="#mlframe.mlframe.MLFrame.get_vif">get_vif</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.get_vif_cols" href="#mlframe.mlframe.MLFrame.get_vif_cols">get_vif_cols</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.index" href="#mlframe.mlframe.MLFrame.index">index</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.info" href="#mlframe.mlframe.MLFrame.info">info</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.jointplot" href="#mlframe.mlframe.MLFrame.jointplot">jointplot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.log" href="#mlframe.mlframe.MLFrame.log">log</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.lrmodel" href="#mlframe.mlframe.MLFrame.lrmodel">lrmodel</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.model" href="#mlframe.mlframe.MLFrame.model">model</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.model_and_plot" href="#mlframe.mlframe.MLFrame.model_and_plot">model_and_plot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.model_resid_scatter" href="#mlframe.mlframe.MLFrame.model_resid_scatter">model_resid_scatter</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.ms_matrix" href="#mlframe.mlframe.MLFrame.ms_matrix">ms_matrix</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.num_cols" href="#mlframe.mlframe.MLFrame.num_cols">num_cols</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.one_hot_encode" href="#mlframe.mlframe.MLFrame.one_hot_encode">one_hot_encode</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.outlier_removal" href="#mlframe.mlframe.MLFrame.outlier_removal">outlier_removal</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.plot_coef" href="#mlframe.mlframe.MLFrame.plot_coef">plot_coef</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.plot_corr" href="#mlframe.mlframe.MLFrame.plot_corr">plot_corr</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.qq_plot" href="#mlframe.mlframe.MLFrame.qq_plot">qq_plot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.regplot" href="#mlframe.mlframe.MLFrame.regplot">regplot</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.replace_all" href="#mlframe.mlframe.MLFrame.replace_all">replace_all</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.scale" href="#mlframe.mlframe.MLFrame.scale">scale</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.train_test_split" href="#mlframe.mlframe.MLFrame.train_test_split">train_test_split</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.wrap__getitem__" href="#mlframe.mlframe.MLFrame.wrap__getitem__">wrap__getitem__</a></code></li>
<li><code><a title="mlframe.mlframe.MLFrame.wrapper" href="#mlframe.mlframe.MLFrame.wrapper">wrapper</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>